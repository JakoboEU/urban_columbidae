---
title: "Urban Columbidae Communities"
output: html_notebook
---

```{r setup, message = F, warning = false}
library(dplyr)
library(purrr)
library(tidyverse)
library(tidyr)


library(phytools)
library(picante)
library(abdiv)
library(vegan)
library(fundiversity)
library(ggpubr)
```

# Introduction
## Are urban columbidae communities strutured by habitat filtering or via competitive interactions?
- With competitive interactions we expect the phylogenetic and functional distance between species to higher than expected than within a random community.
- With habitat filtering we expect the phylogentic and functional distance between species to be lower than expected than within a random community.
(Swenson et al. 2007; Cavender-Bares et al. 2009).

## Recommended community metrics (Trisos et al. 2014)
- Functional diversity of all traits (Petchey and Gaston 2002)
- Convex Hull Volume (CHV) of all traits (a multivariate measure of the range of community values) (Cornwell et al. 2006)
- Mean taxon distance (MPD)  is mean pairwise phylogenetic distances between co-occurring species and is most sensitive to tree-wide patterns of phylogenetic clustering and evenness.
- Mean nearest taxon distance (MNTD) is mean pairwise phylogenetic distances separating each species from its closest co-occurring relative and is most sensitive to phylogenetic clustering or evenness at the tips of phylogeny.
- FD of each trait individually 
- Variance of each trait within community previously used to measure trait clustering
- SDNDr (standard deviation of distances between neighbouring species along a single trait axis, divided by the trait range of the community) is used to detect the regular spacing in species trait values predicted by competitive exclusion.

## Recommended traits (Trisos et al. 2014)
- Overall body size.
- Trophic - beak shape (beak length, width, depth) - measures competitive exclusion (e.g. over-dispersion) via accentuation of foraging differences
- Locomotory (wing, tail, tarsus length)

## Recommended null model (Milar et al. 2017)
Many metrics sensitive to species richness. Urban communities are governed by the surrounding regional pool. For each urban community, we can generate all of the possible communities with the same species richness as the urban community with species from the regional pool.  The average of all possible communities gives us a null model.

# Community data
We used all cities with a population of 250,000 or more, and that have at least 167 complete checklists that are more than 5 and less than 240 minutes in length and cover no more than 10km. We then included any Columbidae species in the urban community that appeared on at least 5% of all of these checklists recorded within the city.

This criteria comes from choosing all cities with at least 1000 checklists, and then testing 1000 times how many checklists are required to find all those species that appear on at least 5% of the total checklists. 269 cities were included in this test, and 167 was the maximum number of checklists required to find all min-5% species (which was in Auckland).

## Read in data exported from bigquery
```{yaml metadata all_columbidae_communities}
models:
  - name: all_columbidae_communities
    description: Regional and urban communities for all cities with a population of at least 250,000 from GHSL Data Package 2019 (Pesaresi et al. 2019), which contain at leasts 167 eBird checklists, and have at least one Columbidae species within their regional pools.
    columns:
      - name: city_id
        description: Vector ID from GHSL Data Package 2019 (Pesaresi et al. 2019)
      - name: city_name
        description: City name from Vector from GHSL Data Package 2019 (Pesaresi et al. 2019)
      - name: jetz_scientific_name
        description: The mapped name of each species whose distribution from BirdLife Internationalâ€™s species distribution maps (BirdLife International and Handbook of the Birds of the World 2020), overlaps with the city vector from GHSL Data Package 2019 (Pesaresi et al. 2019). Species mapped from eBird and Birdlife to JETZ taxonomy using birdlife alternative names and Avibase (Lepage 2011).
      - name: present_in_city
        description: True if the species is present on at least 5% of all valid checklists within the city
```

```{r read all_columbidae_communities}
all_columbidae_communities = read_csv('bigquery_export__columbidae_jetz_urban_locations.csv')
head(all_columbidae_communities)
```
# Site Selection
Our site metrics all compare species within communities, therefore we must have more than one species in each urban community for our analysis.
Our null model requires us to create a range of dissimilar communities with the same richness as the actual urban community using species from the regional pool, therefore we must have less than the number of species in our regional pool in our urban pool.

Here we exclude then two sets of urban communities that are interesting in their own right, (1) those with 1 or less species, and (2) those with all the species from the regional pool

```{r}
urban_communities_tmp = all_columbidae_communities %>% group_by(city_id, city_name) %>% summarise(regional_pool_size = n(), urban_pool_size = sum(present_in_city))
head(urban_communities_tmp)
```
Communities with 1 or less pigeon species
```{r}
urban_communities_tmp[urban_communities_tmp$urban_pool_size < 2,]
```
Communities with all regional species
```{r}
urban_communities_tmp[urban_communities_tmp$urban_pool_size == urban_communities_tmp$regional_pool_size,]
```

```{yaml metadata selected_urban_communities}
models:
  - name: selected_urban_communities
    description: Sites that we will analyse that have more than 1 species, and less species than the entire regional pool
    columns:
      - name: city_id
        description: Vector ID from GHSL Data Package 2019 (Pesaresi et al. 2019)
      - name: city_name
        description: City name from Vector from GHSL Data Package 2019 (Pesaresi et al. 2019)
      - name: regional_pool_size
        description: the number of columbidae species in the city regional pool, e.g. number of species where the city vector overlaps the birdlife distribution vector
      - name: urban_pool_size
        description: the number of columbidae species that occur inside the city, e.g. the number of columbidae species that appear on at least 5% of all valid checklists within the city vector.
```

Selected sites:
```{r create selected_urban_communities}
selected_urban_communities = urban_communities_tmp[urban_communities_tmp$urban_pool_size > 1 & urban_communities_tmp$urban_pool_size != urban_communities_tmp$regional_pool_size,]
nrow(selected_urban_communities)
head(selected_urban_communities)
```
And therefore
```{r}
selected_columbidae_communities = all_columbidae_communities[all_columbidae_communities$city_id %in% selected_urban_communities$city_id,]
head(selected_columbidae_communities)
```

# Trait Data
```{yaml metadata avonet_birdlife}
models:
  - name: avonet_birdlife
    description: Functional traits taken from Avonet (Tobias et al. 2022) which includes core morphologic measurements, along with habitat preference
    columns:
      - name: species_name
        description: The birdlife species name
      - name: beak_length
        description: measured from tip to skull along the culmen
      - name: beak_width
        description: 
      - name: beak_depth
        description:
      - name: tail_length
        description:
      - name: wing_length
        description: carpal joint to wingtip measured on the unflattened wing
      - name: tarsus_length
        description:
      - name: habitat
        description: habitat preference; one of: forest, grassland, human modified, rock, shrubland, woodland, desert
      - name: habitat_density
        description: habitat density preference (1 open to 3 dense)
      - name: trophic_niche
        description: frugivore, granivore, omnivore
      - name: primary_lifestyle
        description: generalist, insessorial, terrestrial
      - name: range_size
        description: extracted range size (km2) from Birdlife
      - name: mass
        description: body mass (grams)
```

```{r read avonet_birdlife}
avonet_birdlife_input_tmp = read_csv('avonet_birdlife.csv')
avonet_birdlife = avonet_birdlife_input_tmp[,c('Species1', 'Beak.Length_Culmen', 'Beak.Width', 'Beak.Depth', 'Tail.Length', 'Wing.Length', 'Tarsus.Length', 'Habitat', 'Habitat.Density', 'Trophic.Niche', 'Primary.Lifestyle', 'Range.Size', 'Mass')]
names(avonet_birdlife) = c('species_name', 'beak_length', 'beak_width', 'beak_depth', 'tail_length', 'wing_length', 'tarsus_length', 'habitat', 'habitat_density', 'trophic_niche', 'primary_lifestyle', 'range_size', 'mass')
head(avonet_birdlife)
```
## Mapping trait data to JETZ taxonomy
```{yaml metadata birdlife_to_jetz_mapping}
models:
  - name: birdlife_to_jetz_mapping
    description: Mapping from birdlife to jetz taxonomies
    columns:
      - name: species_name
        description: The birdlife species name
      - name: jetz_scientific_name
        description: The Jetz species name
```

```{r read birdlife_to_jetz_mapping}
birdlife_to_jetz_mapping = read_csv('bigquery_export__columbidae_taxonomic_mapping.csv')
head(birdlife_to_jetz_mapping)
```
Drop species in taxonomy mapping that are not in our communities - to avoid worrying about species not in our datasets
```{r clean birdlife_to_jetz_mapping}
paste("Species not in dataset", nrow(birdlife_to_jetz_mapping[!birdlife_to_jetz_mapping$jetz_scientific_name %in% selected_columbidae_communities$jetz_scientific_name,]))
paste("Total mapped species", nrow(birdlife_to_jetz_mapping))

birdlife_to_jetz_mapping = birdlife_to_jetz_mapping[birdlife_to_jetz_mapping$jetz_scientific_name %in% selected_columbidae_communities$jetz_scientific_name,]

paste("Remaining species after removal", nrow(birdlife_to_jetz_mapping))
```

Check that we have AVONET data for all species - expect empty set
```{r}
birdlife_to_jetz_mapping[!birdlife_to_jetz_mapping$species_name %in% avonet_birdlife$species_name,]
```

Check that we have mapping entry for all community species - expect empty set
```{r}
selected_columbidae_communities[!selected_columbidae_communities$jetz_scientific_name %in% birdlife_to_jetz_mapping$jetz_scientific_name,]
```

When we map, how many duplicates do we have, and how dissimilar are they?
```{r}
avonet_birdlife_mapped_to_jetz_tmp = left_join(birdlife_to_jetz_mapping, avonet_birdlife)
duplicated_jetz_species_in_avonet = avonet_birdlife_mapped_to_jetz_tmp$jetz_scientific_name[duplicated(avonet_birdlife_mapped_to_jetz_tmp$jetz_scientific_name)]
avonet_birdlife_mapped_to_jetz_tmp[avonet_birdlife_mapped_to_jetz_tmp$jetz_scientific_name %in% duplicated_jetz_species_in_avonet,] %>% arrange(jetz_scientific_name)
```
De-duplicate avonet morphology using mean
```{r create avonet_jetz}
avonet_jetz = avonet_birdlife_mapped_to_jetz_tmp %>% group_by(jetz_scientific_name) %>% summarize(
  beak_length = mean(beak_length),
  beak_width = mean(beak_width),
  beak_depth = mean(beak_depth),
  tail_length = mean(tail_length),
  wing_length = mean(wing_length),
  tarsus_length = mean(tarsus_length),
  trophic_niche = first(trophic_niche),
  habitat = first(habitat),
  habitat_density = first(habitat_density),
  primary_lifestyle = first(primary_lifestyle),
  range_size = sum(range_size),
  mass = mean(mass)
)
head(avonet_jetz)
```
Check duplicates
```{r}
avonet_jetz[avonet_jetz$jetz_scientific_name %in% duplicated_jetz_species_in_avonet,]
```

## Creating trait values

### Trophic trait
```{r}
trophic_trait_pca = rda(avonet_jetz[,c('beak_length', 'beak_width', 'beak_depth')])
summary(trophic_trait_pca)
```
Does the new trophic trait explain trophic niche?
```{r}
summary(glm(formula = niche ~ pc1, data = data.frame(niche = as.factor(avonet_jetz$trophic_niche), pc1 = trophic_trait_pca$Ybar[,1]), family = binomial))
```
Is PC1 correlated to mass?
```{r}
cor(trophic_trait_pca$Ybar[,1], avonet_jetz$mass)
```

```{r}
avonet_jetz$trophic_trait = trophic_trait_pca$Ybar[,1]
```

### Locomotory trait
```{r}
locomotry_trait_pca = rda(avonet_jetz[,c('tarsus_length', 'wing_length', 'tail_length')])
summary(locomotry_trait_pca)
```

Is PC1 correlated to mass?
```{r}
cor(locomotry_trait_pca$Ybar[,1], avonet_jetz$mass)
```

```{r}
avonet_jetz$locomotory_trait = locomotry_trait_pca$Ybar[,1]
```

# Calculate city wide community values

## First build out matrix of all urban communities
```{r create species_in_cities}
species_in_cities = pivot_wider(selected_columbidae_communities[selected_columbidae_communities$present_in_city,], names_from = jetz_scientific_name, values_from = "present_in_city", values_fill = list(present_in_city = F))
species_in_cities = tibble::column_to_rownames(species_in_cities, var='city_id')
species_in_cities = species_in_cities[,-1]
species_in_cities
```
## Read in phylogeny
Phylogenetic maximum clade tree based on a set of trees from Jetz et al. (2012) using the Hacket et al. (2008) backbone.
Trim tree to just species within our urban communities
```{r}
all_avian_species_tree <- read.tree("./phylogeny__stage2_hackett_mcc_no_neg.tre")
columbidae_tree <- ladderize(drop.tip(all_avian_species_tree, setdiff(all_avian_species_tree$tip.label, selected_columbidae_communities$jetz_scientific_name)))
```

Check that we have all species in our tree - expect empty dataset
```{r}
selected_columbidae_communities[!selected_columbidae_communities$jetz_scientific_name %in% columbidae_tree$tip.label,]
```

## MNTD
Using picante package https://cran.r-project.org/web/packages/picante/index.html
Kembel, S.W., Cowan,P.D., Helmus, M.R., Cornwell, W.K., Morlon, H., Ackerly, D.D., Blomberg, S.P., Webb, C.O. (2010) Picante: {R} tools for integrating phylogenies and ecology. Bioinformatics, 26, 1463-1464
```{r get_mntd_for_communities}
get_mntd_for_communities = function(communities, phydist_urban_columbidae = cophenetic(columbidae_tree)) {
  urban_community_mntd_result = mntd(as.matrix(communities), phydist_urban_columbidae)
  data.frame(site = rownames(communities), mntd = urban_community_mntd_result)
}

get_mntd_for_communities(species_in_cities)
```

## MPD
Using picante package https://cran.r-project.org/web/packages/picante/index.html
Citation above.
```{r get_mpd_for_communities}
get_mpd_for_communities = function(communities, phydist_urban_columbidae = cophenetic(columbidae_tree)) {
  urban_community_mpd_result = mpd(as.matrix(communities), phydist_urban_columbidae)
  data.frame(site = rownames(communities), mpd = urban_community_mpd_result)
}

get_mpd_for_communities(species_in_cities)
```

## FD - Petchey and Gaston
From
https://github.com/NGSwenson/SwensonSESYNCWorkshop2017/blob/5a966564d6896ff0f41dc4ac0a6216f97b9d18e1/day.1.pm/tree.based.alpha.R

Petchey, O.L. and Gaston, K.J. (2002), Functional diversity (FD), species richness and community composition. Ecology Letters, 5: 402-411

Create dentrogram
```{r get_dentrogram_for_traits, fig.height=4}
analysis_all_traits = c('mass', 'locomotory_trait', 'trophic_trait')

get_traits_data_frame = function(trait_names) {
  trait_names = prepend('jetz_scientific_name', trait_names)
  traits = avonet_jetz[,trait_names]
  traits = tibble::column_to_rownames(traits, var='jetz_scientific_name')
  traits
}

get_dentrogram_for_traits = function(required_traits_for_dentro) {
  traits = get_traits_data_frame(required_traits_for_dentro)
  hclust(dist(traits,method="euclidean"), method="average")
}

dentro = get_dentrogram_for_traits(analysis_all_traits)
plot(dentro)
```

Petchey and Gaston's FD
```{r get_fd_for_traits}
get_fd_for_traits = function(required_traits_for_pd, communities, dentorgram = get_dentrogram_for_traits(required_traits_for_pd)) {
  result = pd(communities, as.phylo(dentorgram))
  data.frame(site = rownames(result), fd = result$PD)
}

urban_community_fd_result = get_fd_for_traits(analysis_all_traits, species_in_cities)
head(urban_community_fd_result)
```

```{r}
urban_community_fd_mass_result = get_fd_for_traits(c('locomotory_trait'), species_in_cities)
head(urban_community_fd_mass_result)
```
## Trait Variance
### FRic - Convex Hull of all traits
Using fundiversity package https://cran.r-project.org/web/packages/fundiversity/index.html
GreniÃ© M, Gruson H (2022). fundiversity: Easy Computation of Functional Diversity Indices. doi:10.5281/zenodo.4761754, R package version 1.1.1

```{r get_convex_hull}
get_convex_hull = function(trait_names, communities) {
  analysis_trait_values = get_traits_data_frame(trait_names)
  fd_fric(analysis_trait_values, communities)
}

get_convex_hull(analysis_all_traits)
```

### Single Trait Variance
How to get names of species in urban community:
```{r}
species_in_514 = species_in_cities[c('514'),]
species_names_in_514 = names(species_in_514)[which(species_in_514 == 1, arr.ind=T)[, "col"]]
species_names_in_514
```

How to get values of traits for species in urban community, and then var of those traits:
```{r trait_values}
trait_values = function(trait, community_row) {
  species_names_in_community = names(community_row)[which(community_row == 1, arr.ind=T)[, "col"]]
  traits_for_species_in_community = avonet_jetz[avonet_jetz$jetz_scientific_name %in% species_names_in_community, ]
  traits_for_species_in_community[[c(trait)]]
}

trait_values('mass', species_in_cities[c('514'),])
var(trait_values('mass', species_in_cities[c('514'),]))
```

Turn into a function:
```{r single_trait_variance}
single_trait_variance = function(trait, communities) {
  variance_of_trait = data.frame()
  for(row in rownames(communities)) {
    community_row = communities[c(row),]
    species_names_in_community = names(community_row)[which(community_row == 1, arr.ind=T)[, "col"]]
    
    result = data.frame(site = row, variance = var(trait_values(trait, community_row)))
    variance_of_trait = rbind(variance_of_trait, result)
  }
  
  variance_of_trait
}

single_trait_variance('mass', species_in_cities)
```
## SDNDr
Standard deviation of distances between neighbouring species along a single trait axis, divided by the trait range of the community.

How to calculate SDNDr using trait values for an urban community:
```{r}
print('trait values:')
sorted_loco_traits_in_1291 = sort(trait_values('locomotory_trait', species_in_cities[c('1291'),]))
sorted_loco_traits_in_1291 

print('diff in neighbouring trait values:')
diff(sorted_loco_traits_in_1291)

print('SDNDr:')
sd(diff(sorted_loco_traits_in_1291)) / (max(sorted_loco_traits_in_1291) - min(sorted_loco_traits_in_1291))
```
Turn into a function:
```{r SDNDr}
SDNDr = function(trait, communities) {
  sdndr_of_trait = data.frame()
  for(row in rownames(communities)) {
    community_row = communities[c(row),]
    
    sorted_trait_values = sort(trait_values(trait, community_row))
    
    sdndr_value = sd(diff(sorted_trait_values)) / (max(sorted_trait_values) - min(sorted_trait_values))
    
    sdndr_of_trait = rbind(sdndr_of_trait, data.frame(site = row, sdndr = sdndr_value))
  }
  
  sdndr_of_trait
}

SDNDr('locomotory_trait', species_in_cities)
```

## Put it all together
```{r get_community_metrics}
get_community_metrics = function(communities, included_traits = analysis_all_traits) {

  mntd_result = get_mntd_for_communities(communities)
  mpd_result = get_mpd_for_communities(communities)
  fd_all_traits = get_fd_for_traits(included_traits, communities)
  convex_hull = get_convex_hull(included_traits, communities)
  
  result = right_join(right_join(mntd_result, mpd_result), right_join(fd_all_traits, convex_hull))
  
  for (trait in included_traits) {
    col_name = function(value) {
      paste(trait, value, sep = '_')
    }
  
    fd_single_trait = get_fd_for_traits(trait, communities)
    var_single_trait = single_trait_variance(trait, communities)
    sdndr_single_trait = SDNDr(trait, communities)
    
    single_trait_result = right_join(right_join(fd_single_trait, var_single_trait), sdndr_single_trait)
    names(single_trait_result) = c('site', col_name('fd'), col_name('var'), col_name('sdndr'))
    result = right_join(result, single_trait_result)
  }
  
  result
}
```

```{r create urban_community_values}
urban_community_values = get_community_metrics(species_in_cities)
urban_community_values
```

# Calculate the null models
Our null model is every possible community of species from the regional pool with the same richness as the urban pool

Find all species in regional pool:
```{r}
test_city_id = 1786 # Manchester
test_city_id2 = 2284 # Geneva

all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == test_city_id]
```

```{r}
all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == test_city_id]
```

Find urban richness
```{r}
selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == test_city_id]
```

Function to build every possible community
```{r create_null_model_communities}
create_null_model_communities = function(city_id) {
  regional_species = all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == city_id]
  regional_richness = length(regional_species)
  urban_richness = selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == city_id]
  
  null_model_sites = expand.grid(rep(list(TRUE:FALSE), regional_richness))
  null_model_sites_species_richness =  data.frame(species_richness = pmap_dbl(null_model_sites, sum))
  null_model_sites = cbind(null_model_sites, null_model_sites_species_richness)
  
  null_model_sites = null_model_sites[null_model_sites$species_richness == urban_richness,1:regional_richness]
  colnames(null_model_sites) = regional_species
  null_model_sites
}

create_null_model_communities(test_city_id)
```

What were the results for the actual urban community in Manchester?
```{r}
urban_community_values[urban_community_values$site == test_city_id,]
```

Test creating community metrics for our null model
```{r}
test_null_models = create_null_model_communities(test_city_id)

test_null_model_community_values = get_community_metrics(test_null_models)
test_null_model_community_values
```

```{r}
get_community_metrics(create_null_model_communities(test_city_id2))
```

# Compare Urban Communities to regional null models
```{r normalise}
normalise = function(actual_value, min_value, max_value) {
  (actual_value - min_value) / (max_value - min_value)
}

normalise(1.5, 1, 2)
```

```{r standardise}
standardise = function(actual_value, mean_value, sd) {
  (actual_value - mean_value) / sd
}

standardise(1.5, 1, 0.25)
```

Test creating normalised and standardised FRic
```{r}
property = 'FRic'
actual_value = urban_community_values[urban_community_values$site == test_city_id,c(property)]
null_model_values = test_null_model_community_values[,c(property)]

print(paste('Normalised', property, 'at site', test_city_id))
normalise(actual_value, min(null_model_values), max(null_model_values))
print(paste('Standardised', property, 'at site', test_city_id))
standardise(actual_value, mean(null_model_values), sd(null_model_values))
```

Create function to test actual value against all possible null model values
```{r compare_community_to_null_model}
compare_community_to_null_model = function(metric_name, actual_metric_value, null_model_metric_values) {
  min_value = min(null_model_metric_values)
  max_value = max(null_model_metric_values)
  mean_value = mean(null_model_metric_values)
  sd_value = sd(null_model_metric_values)
  
  result = data.frame(
    normalised = normalise(actual_metric_value, min_value, max_value),
    stanardised = standardise(actual_metric_value, mean_value, sd_value),
    actual = actual_metric_value,
    min = min_value,
    max = max_value,
    mean = mean_value,
    sd = sd_value
  )
  
  col_name = function(value) {
      paste(metric_name, value, sep = '_')
  }
  
  colnames(result) = c(col_name('normalised'), col_name('standardised'), col_name('actual'), col_name('min'), col_name('max'), col_name('mean'), col_name('sd'))
  result
}

compare_community_to_null_model(property, actual_value, null_model_values)
```

The metrics we want to test:
```{r create all_metrics_to_test}
all_metrics_to_test = colnames(urban_community_values)[-1]
all_metrics_to_test
```

```{r create_null_model_test_values}
create_null_model_test_values = function(city_id) {
  null_models = create_null_model_communities(city_id)
  null_model_community_values = get_community_metrics(null_models)
  
  actual_values = urban_community_values[urban_community_values$site == city_id,]
  
  result = data.frame(city_id = city_id)
  
  for (metric in all_metrics_to_test) {
    result = cbind(result, 
                   compare_community_to_null_model(metric, actual_values[,c(metric)], null_model_community_values[,c(metric)]))
  }
  result
}

create_null_model_test_values(test_city_id)
```

```{r}
create_null_model_test_values(test_city_id2)
```

```{r create urban_community_result, eval = FALSE}
urban_community_result = data.frame()

for (city_id in selected_urban_communities$city_id) {
  urban_community_result = rbind(urban_community_result, create_null_model_test_values(city_id))
}

write_csv(urban_community_result, './community_assembly_result.csv')
head(urban_community_result)
```

```{r}
urban_community_result = read_csv('./community_assembly_result.csv')
urban_community_result
```

# Analysis
Total number of cities in analysis
```{r}
nrow(urban_community_result)
```

## Analysis of all traits across entire community

### MNTD
Pairwise phylogenetic distances separating each species from its closest co-occurring relative and is most sensitive to phylogenetic clustering or evenness at the tips of phylogeny.

```{r}
fmt_p_value = function(test_result) {
  ifelse(test_result$p.value > 0.001, paste('=', round(test_result$p.value, 3)), '< 0.001')
}

geom_standardised_histogram = function(name, gg, test_result, mean) {
    gg + geom_histogram(color = "#000000", fill = "#0099F8", binwidth = 0.25) +
    geom_vline(aes(xintercept = 0), color = "#000000", size = 1.25) +
    geom_vline(aes(xintercept = -1), color = "#000000", size = 1, linetype = "dashed") +
    geom_vline(aes(xintercept = 1), color = "#000000", size = 1, linetype = "dashed") + 
    ylab("Number of cities") + xlab("Standardised Response") + ylim(c(0, 150)) + xlim(c(-3, 3)) +
    labs(title = name, subtitle=paste('(V=', test_result$statistic, ', p-value ', fmt_p_value(test_result), ', mean = ', round(mean, 2), ')', sep=''))
}

geom_normalised_histogram = function(name, gg, test_result, mean) {
  gg + geom_histogram(color = "#000000", fill = "#0099F8", binwidth = 0.1) +
  geom_vline(aes(xintercept = 0.5), color = "#000000", size = 1.25) +
  geom_vline(aes(xintercept = 0), color = "#000000", size = 1, linetype = "dashed") +
  geom_vline(aes(xintercept = 1), color = "#000000", size = 1, linetype = "dashed") + 
  ylab("Number of cities") + xlab("Normalised Response") + ylim(c(0, 200)) +
  labs(title = name, subtitle = paste('(V=', test_result$statistic, ', p-value ', fmt_p_value(test_result), ', mean = ', round(mean, 2), ')', sep=''))
}
```

```{r}
std_mntd_analysis_plot = geom_standardised_histogram(
  'MNTD', 
  ggplot(urban_community_result, aes(mntd_standardised)), 
  wilcox.test(urban_community_result$mntd_standardised, mu = 0), 
  mean(urban_community_result$mntd_standardised)
)
std_mntd_analysis_plot
```

```{r}
norm_mntd_analysis_plot = geom_normalised_histogram(
  'MNTD', 
  ggplot(urban_community_result, aes(mntd_normalised)), 
  wilcox.test(urban_community_result$mntd_normalised, mu = 0.5), 
  mean(urban_community_result$mntd_normalised)
)
norm_mntd_analysis_plot
```

```{r}
cities_ids_for_low_normalised_mntd = urban_community_result$city_id[urban_community_result$mntd_normalised < 0.2]
selected_urban_communities[selected_urban_communities$city_id %in% cities_ids_for_low_normalised_mntd,]
```

### MPD
Mean pairwise phylogenetic distances between co-occurring species and is most sensitive to tree-wide patterns of phylogenetic clustering and evenness.

```{r}
std_mpd_analysis_plot = geom_standardised_histogram(
  'MPD', 
  ggplot(urban_community_result, aes(mpd_standardised)), 
  wilcox.test(urban_community_result$mpd_standardised, mu = 0), 
  mean(urban_community_result$mpd_standardised)
)
std_mpd_analysis_plot
```

```{r}
norm_mpd_analysis_plot = geom_normalised_histogram(
  'MNTD', 
  ggplot(urban_community_result, aes(mpd_normalised)), 
  wilcox.test(urban_community_result$mpd_normalised, mu = 0.5), 
  mean(urban_community_result$mpd_normalised)
)
norm_mpd_analysis_plot
```


### All Traits FD
Test normalised value
```{r}
std_fd_analysis_plot = geom_standardised_histogram(
  'FD', 
  ggplot(urban_community_result, aes(fd_standardised)), 
  wilcox.test(urban_community_result$fd_standardised, mu = 0), 
  mean(urban_community_result$fd_standardised)
)
std_fd_analysis_plot
```

```{r}
norm_fd_analysis_plot = geom_normalised_histogram(
  'FD', 
  ggplot(urban_community_result, aes(fd_normalised)), 
  wilcox.test(urban_community_result$fd_normalised, mu = 0.5), 
  mean(urban_community_result$fd_normalised)
)
norm_fd_analysis_plot
```

### FRic
Number of cities that we could calculate FRic for, need 4 or more species (as require more species than traits)
```{r}
std_fric_analysis_plot = geom_standardised_histogram(
  'FRic', 
  ggplot(urban_community_result, aes(FRic_standardised)), 
  wilcox.test(urban_community_result$FRic_standardised, mu = 0), 
  mean(urban_community_result$FRic_standardised, na.rm = T)
)
std_fric_analysis_plot
```

```{r}
norm_fric_analysis_plot = geom_normalised_histogram(
  'FRic', 
  ggplot(urban_community_result, aes(FRic_normalised)), 
  wilcox.test(urban_community_result$FRic_normalised, mu = 0.5), 
  mean(urban_community_result$FRic_normalised, na.rm = T)
)
norm_fric_analysis_plot
```

## Single Trait Metrics

Number of cities we can calculate SDNDr for - require at least 3 species
```{r}
nrow(urban_community_result[!is.na(urban_community_result$mass_sdndr_actual),])
```

### Locomotory Trait

#### FD
```{r}
std_loco_trait_fd_analysis_plot = geom_standardised_histogram(
  'Locomotory Trait - FD', 
  ggplot(urban_community_result, aes(locomotory_trait_fd_standardised)), 
  wilcox.test(urban_community_result$locomotory_trait_fd_standardised, mu = 0), 
  mean(urban_community_result$locomotory_trait_fd_standardised, na.rm = T)
)
std_loco_trait_fd_analysis_plot
```

```{r}
norm_loco_trait_fd_analysis_plot = geom_normalised_histogram(
  'Locomotory Trait - FD', 
  ggplot(urban_community_result, aes(locomotory_trait_fd_normalised)), 
  wilcox.test(urban_community_result$locomotory_trait_fd_normalised, mu = 0.5), 
  mean(urban_community_result$locomotory_trait_fd_normalised, na.rm = T)
)
norm_loco_trait_fd_analysis_plot
```

#### VAR
```{r}
std_loco_trait_var_analysis_plot = geom_standardised_histogram(
  'Locomotory Trait - VAR', 
  ggplot(urban_community_result, aes(locomotory_trait_var_standardised)), 
  wilcox.test(urban_community_result$locomotory_trait_var_standardised, mu = 0), 
  mean(urban_community_result$locomotory_trait_var_standardised, na.rm = T)
)
std_loco_trait_var_analysis_plot
```

```{r}
norm_loco_trait_var_analysis_plot = geom_normalised_histogram(
  'Locomotory Trait - VAR', 
  ggplot(urban_community_result, aes(locomotory_trait_var_normalised)), 
  wilcox.test(urban_community_result$locomotory_trait_var_normalised, mu = 0.5), 
  mean(urban_community_result$locomotory_trait_var_normalised, na.rm = T)
)
norm_loco_trait_var_analysis_plot
```

#### SDNDr
```{r}
std_loco_trait_sdndr_analysis_plot = geom_standardised_histogram(
  'Locomotory Trait - SDNDr', 
  ggplot(urban_community_result, aes(locomotory_trait_sdndr_standardised)), 
  wilcox.test(urban_community_result$locomotory_trait_sdndr_standardised, mu = 0), 
  mean(urban_community_result$locomotory_trait_sdndr_standardised, na.rm = T)
)
std_loco_trait_sdndr_analysis_plot
```

```{r}
norm_loco_trait_sdndr_analysis_plot = geom_normalised_histogram(
  'Locomotory Trait - SDNDr', 
  ggplot(urban_community_result, aes(locomotory_trait_sdndr_normalised)), 
  wilcox.test(urban_community_result$locomotory_trait_sdndr_normalised, mu = 0.5), 
  mean(urban_community_result$locomotory_trait_sdndr_normalised, na.rm = T)
)
norm_loco_trait_sdndr_analysis_plot
```


### Trophic Trait

#### FD
```{r}
std_trophic_trait_fd_analysis_plot = geom_standardised_histogram(
  'Trophic Trait - FD', 
  ggplot(urban_community_result, aes(trophic_trait_fd_standardised)), 
  wilcox.test(urban_community_result$trophic_trait_fd_standardised, mu = 0), 
  mean(urban_community_result$trophic_trait_fd_standardised, na.rm = T)
)
std_trophic_trait_fd_analysis_plot
```

```{r}
norm_trophic_trait_fd_analysis_plot = geom_normalised_histogram(
  'Trophic Trait - FD', 
  ggplot(urban_community_result, aes(trophic_trait_fd_normalised)), 
  wilcox.test(urban_community_result$trophic_trait_fd_normalised, mu = 0.5), 
  mean(urban_community_result$trophic_trait_fd_normalised, na.rm = T)
)
norm_trophic_trait_fd_analysis_plot
```


#### VAR
```{r}
std_trophic_trait_var_analysis_plot = geom_standardised_histogram(
  'Trophic Trait - VAR', 
  ggplot(urban_community_result, aes(trophic_trait_var_standardised)), 
  wilcox.test(urban_community_result$trophic_trait_var_standardised, mu = 0), 
  mean(urban_community_result$trophic_trait_var_standardised, na.rm = T)
)
std_trophic_trait_var_analysis_plot
```

```{r}
norm_trophic_trait_var_analysis_plot = geom_normalised_histogram(
  'Trophic Trait - VAR', 
  ggplot(urban_community_result, aes(trophic_trait_var_normalised)), 
  wilcox.test(urban_community_result$trophic_trait_var_normalised, mu = 0.5), 
  mean(urban_community_result$trophic_trait_var_normalised, na.rm = T)
)
norm_trophic_trait_var_analysis_plot
```


#### SDNDr
```{r}
std_trophic_trait_sdndr_analysis_plot = geom_standardised_histogram(
  'Trophic Trait - SDNDr', 
  ggplot(urban_community_result, aes(trophic_trait_sdndr_standardised)), 
  wilcox.test(urban_community_result$trophic_trait_sdndr_standardised, mu = 0), 
  mean(urban_community_result$trophic_trait_sdndr_standardised, na.rm = T)
)
std_trophic_trait_sdndr_analysis_plot
```

```{r}
norm_trophic_trait_sdndr_analysis_plot = geom_normalised_histogram(
  'Trophic Trait - SDNDr', 
  ggplot(urban_community_result, aes(trophic_trait_sdndr_normalised)), 
  wilcox.test(urban_community_result$trophic_trait_sdndr_normalised, mu = 0.5), 
  mean(urban_community_result$trophic_trait_var_normalised, na.rm = T)
)
norm_trophic_trait_sdndr_analysis_plot
```


### Mass

#### FD
```{r}
std_mass_fd_analysis_plot = geom_standardised_histogram(
  'Mass - FD', 
  ggplot(urban_community_result, aes(mass_fd_standardised)), 
  wilcox.test(urban_community_result$mass_fd_standardised, mu = 0), 
  mean(urban_community_result$mass_fd_standardised, na.rm = T)
)
std_mass_fd_analysis_plot
```

```{r}
norm_mass_fd_analysis_plot = geom_normalised_histogram(
  'Mass - FD', 
  ggplot(urban_community_result, aes(mass_fd_normalised)), 
  wilcox.test(urban_community_result$mass_fd_normalised, mu = 0.5), 
  mean(urban_community_result$mass_fd_normalised, na.rm = T)
)
norm_mass_fd_analysis_plot
```


#### VAR
```{r}
std_mass_var_analysis_plot = geom_standardised_histogram(
  'Mass - VAR', 
  ggplot(urban_community_result, aes(mass_var_standardised)), 
  wilcox.test(urban_community_result$mass_var_standardised, mu = 0), 
  mean(urban_community_result$mass_var_standardised, na.rm = T)
)
std_mass_var_analysis_plot
```

```{r}
norm_mass_var_analysis_plot = geom_normalised_histogram(
  'Mass - VAR', 
  ggplot(urban_community_result, aes(mass_var_normalised)), 
  wilcox.test(urban_community_result$mass_var_normalised, mu = 0.5), 
  mean(urban_community_result$mass_var_normalised, na.rm = T)
)
norm_mass_var_analysis_plot
```


#### SDNDr
```{r}
std_mass_sdndr_analysis_plot = geom_standardised_histogram(
  'Mass - SDNDr', 
  ggplot(urban_community_result, aes(mass_sdndr_standardised)), 
  wilcox.test(urban_community_result$mass_sdndr_standardised, mu = 0), 
  mean(urban_community_result$mass_sdndr_standardised, na.rm = T)
)
std_mass_sdndr_analysis_plot
```

```{r}
norm_mass_sdndr_analysis_plot = geom_normalised_histogram(
  'Mass - SDNDr', 
  ggplot(urban_community_result, aes(mass_sdndr_normalised)), 
  wilcox.test(urban_community_result$mass_sdndr_normalised, mu = 0.5), 
  mean(urban_community_result$mass_sdndr_normalised, na.rm = T)
)
norm_mass_sdndr_analysis_plot
```

## Create Figures

### All Traits

Standardised
```{r, fig.height=3, fig.width=3}
ggarrange(std_mntd_analysis_plot, std_mpd_analysis_plot, std_fric_analysis_plot, std_fd_analysis_plot, ncol = 2, nrow = 2)
```
Normalised
```{r, fig.height=3, fig.width=3}
ggarrange(norm_mntd_analysis_plot, norm_mpd_analysis_plot, norm_fric_analysis_plot, norm_fd_analysis_plot, ncol = 2, nrow = 2)
```
### Single Traits
Standardised
```{r, fig.height=6, fig.width=6}
ggarrange(
  std_loco_trait_fd_analysis_plot, std_loco_trait_var_analysis_plot, std_loco_trait_sdndr_analysis_plot,
  std_trophic_trait_fd_analysis_plot, std_trophic_trait_var_analysis_plot, std_trophic_trait_sdndr_analysis_plot,
  std_mass_fd_analysis_plot, std_mass_var_analysis_plot, std_mass_sdndr_analysis_plot,
  ncol = 3, nrow = 3)
```
Normalised
```{r, fig.height=6, fig.width=6}
ggarrange(
  norm_loco_trait_fd_analysis_plot, norm_loco_trait_var_analysis_plot, norm_loco_trait_sdndr_analysis_plot,
  norm_trophic_trait_fd_analysis_plot, norm_trophic_trait_var_analysis_plot, norm_trophic_trait_sdndr_analysis_plot,
  norm_mass_fd_analysis_plot, norm_mass_var_analysis_plot, norm_mass_sdndr_analysis_plot,
  ncol = 3, nrow = 3)
```
