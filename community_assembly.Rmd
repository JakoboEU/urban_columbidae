---
title: "Urban Columbidae Communities"
output: html_notebook
---

```{r setup, message = F, warning = false}
library(dplyr)
library(purrr)
library(tidyverse)
library(tidyr)


library(phytools)
library(picante)
library(abdiv)
library(vegan)
library(fundiversity)
library(ggpubr)
library(gridExtra)
library(grid)
```

# Introduction
## Are urban columbidae communities strutured by habitat filtering or via competitive interactions?
- With competitive interactions we expect the phylogenetic and functional distance between species to higher than expected than within a random community.
- With habitat filtering we expect the phylogentic and functional distance between species to be lower than expected than within a random community.
(Swenson et al. 2007; Cavender-Bares et al. 2009).

## Recommended community metrics (Trisos et al. 2014)
- Functional diversity of all traits (Petchey and Gaston 2002)
- Convex Hull Volume (CHV) of all traits (a multivariate measure of the range of community values) (Cornwell et al. 2006)
- Mean taxon distance (MTD)  is mean pairwise phylogenetic distances between co-occurring species and is most sensitive to tree-wide patterns of phylogenetic clustering and evenness.
- Mean nearest taxon distance (MNTD) is mean pairwise phylogenetic distances separating each species from its closest co-occurring relative and is most sensitive to phylogenetic clustering or evenness at the tips of phylogeny.
- FD of each trait individually 
- Variance of each trait within community previously used to measure trait clustering
- SDNDr (standard deviation of distances between neighbouring species along a single trait axis, divided by the trait range of the community) is used to detect the regular spacing in species trait values predicted by competitive exclusion.

## Recommended traits (Trisos et al. 2014)
- Overall body size.
- Trophic - beak shape (beak length, width, depth) - measures competitive exclusion (e.g. over-dispersion) via accentuation of foraging differences
- Locomotory (wing, tail, tarsus length)

## Recommended null model (Milar et al. 2017)
Many metrics sensitive to species richness. Urban communities are governed by the surrounding regional pool. For each urban community, we can generate all of the possible communities with the same species richness as the urban community with species from the regional pool.  The average of all possible communities gives us a null model.

# Community data
We used all cities with a population of 250,000 or more, and that have at least 167 complete checklists that are more than 5 and less than 240 minutes in length and cover no more than 10km. We then included any Columbidae species in the urban community that appeared on at least 5% of all of these checklists recorded within the city.

This criteria comes from choosing all cities with at least 1000 checklists, and then testing 1000 times how many checklists are required to find all those species that appear on at least 5% of the total checklists. 269 cities were included in this test, and 167 was the maximum number of checklists required to find all min-5% species (which was in Auckland).

## Read in data exported from bigquery
```{yaml metadata all_columbidae_communities}
models:
  - name: all_columbidae_communities
    description: Regional and urban communities for all cities with a population of at least 250,000 from GHSL Data Package 2019 (Pesaresi et al. 2019), which contain at leasts 167 eBird checklists, and have at least one Columbidae species within their regional pools.
    columns:
      - name: city_id
        description: Vector ID from GHSL Data Package 2019 (Pesaresi et al. 2019)
      - name: city_name
        description: City name from Vector from GHSL Data Package 2019 (Pesaresi et al. 2019)
      - name: jetz_scientific_name
        description: The mapped name of each species whose distribution from BirdLife Internationalâ€™s species distribution maps (BirdLife International and Handbook of the Birds of the World 2020), overlaps with the city vector from GHSL Data Package 2019 (Pesaresi et al. 2019). Species mapped from eBird and Birdlife to JETZ taxonomy using birdlife alternative names and Avibase (Lepage 2011).
      - name: present_in_city
        description: True if the species is present on at least 5% of all valid checklists within the city
      - name: season_code 
        description: season code from BirdLife International and Handbook of the Birds of the World 2020
      - name: season
        description: Textual description of Birdlife's season code
      - name: origin_code 
        description: origin code from BirdLife International and Handbook of the Birds of the World 2020
      - name: origin
        description: Textual description of Birdlife's origin code
```

```{r read all_columbidae_communities}
all_columbidae_communities = read_csv('bigquery_export__columbidae_jetz_urban_locations.csv')
head(all_columbidae_communities)
```

# Site Selection
Our site metrics all compare species within communities, therefore we must have more than one species in each urban community for our analysis.
Our null model requires us to create a range of dissimilar communities with the same richness as the actual urban community using species from the regional pool, therefore we must have less than the number of species in our regional pool in our urban pool.

Here we exclude then two sets of urban communities that are interesting in their own right, (1) those with 1 or less species, and (2) those with all the species from the regional pool

```{r}
urban_communities_tmp = all_columbidae_communities %>% group_by(city_id, city_name) %>% summarise(regional_pool_size = n(), urban_pool_size = sum(present_in_city), number_of_regional_introduced_species = sum(origin == 'Introduced'), number_of_urban_introduced_species = sum(origin == 'Introduced' & present_in_city))
head(urban_communities_tmp)
```

Communities with 1 or less pigeon species
```{r}
urban_communities_tmp[urban_communities_tmp$urban_pool_size < 2,]
```
Communities with all regional species
```{r}
urban_communities_tmp[urban_communities_tmp$urban_pool_size == urban_communities_tmp$regional_pool_size,]
```

```{yaml metadata selected_urban_communities}
models:
  - name: selected_urban_communities
    description: Sites that we will analyse that have more than 1 species, and less species than the entire regional pool
    columns:
      - name: city_id
        description: Vector ID from GHSL Data Package 2019 (Pesaresi et al. 2019)
      - name: city_name
        description: City name from Vector from GHSL Data Package 2019 (Pesaresi et al. 2019)
      - name: regional_pool_size
        description: the number of columbidae species in the city regional pool, e.g. number of species where the city vector overlaps the birdlife distribution vector
      - name: urban_pool_size
        description: the number of columbidae species that occur inside the city, e.g. the number of columbidae species that appear on at least 5% of all valid checklists within the city vector.
      - name: number_of_regional_introduced_species
        description: the number of columbidae species in the regional pool that are introduced, e.g. have origin 'Introduced' from the Birdlife distribution vector.
      - name: number_of_urban_introduced_species
        description: the number of columbidae species present inside the city that are introduced, e.g. have origin 'Introduced' from the Birdlife distribution vector.
```

Selected sites:
```{r create selected_urban_communities}
selected_urban_communities = urban_communities_tmp[urban_communities_tmp$urban_pool_size > 1 & urban_communities_tmp$urban_pool_size != urban_communities_tmp$regional_pool_size,]
nrow(selected_urban_communities)
head(selected_urban_communities)
```

And therefore
```{r}
selected_columbidae_communities = all_columbidae_communities[all_columbidae_communities$city_id %in% selected_urban_communities$city_id,]
head(selected_columbidae_communities)
```
Total number of species across regional pools:
```{r}
length(unique(selected_columbidae_communities$jetz_scientific_name))
```

Total number of species across cities:
```{r}
length(unique(selected_columbidae_communities$jetz_scientific_name[selected_columbidae_communities$present_in_city]))
```

## Create a second set containing only Resident species
We have shown that non-resident species are less likely to be present in urban communities; however, this could be temporal sampling bias that means non-resident species are less likely to appear on at least 5% of all checklists. Therefore we should validate our findings against a second dataset that contains only resident species.

```{r}
all_resident_columbidae_communities = all_columbidae_communities[all_columbidae_communities$season == 'Resident',]
head(all_resident_columbidae_communities)
```

```{r}
resident_urban_communities_tmp = all_resident_columbidae_communities %>% group_by(city_id, city_name) %>% summarise(regional_pool_size = n(), urban_pool_size = sum(present_in_city))
head(resident_urban_communities_tmp)
```

```{yaml metadata selected_resident_only_urban_communities}
models:
  - name: selected_resident_only_urban_communities
    description: Sites that we will analyse that have more than 1 species, and less species than the entire regional pool based on species being within their Residential range (and not just Breeding, Migration, or non-Breeding range).
    columns:
      - name: city_id
        description: Vector ID from GHSL Data Package 2019 (Pesaresi et al. 2019)
      - name: city_name
        description: City name from Vector from GHSL Data Package 2019 (Pesaresi et al. 2019)
      - name: regional_pool_size
        description: the number of columbidae species in the city regional pool, e.g. number of species where the city vector overlaps the birdlife distribution vector
      - name: urban_pool_size
        description: the number of columbidae species that occur inside the city, e.g. the number of columbidae species that appear on at least 5% of all valid checklists within the city vector.
```

Selected sites:
```{r create selected_resident_only_urban_communities}
selected_resident_only_urban_communities = resident_urban_communities_tmp[resident_urban_communities_tmp$urban_pool_size > 1 & resident_urban_communities_tmp$urban_pool_size != resident_urban_communities_tmp$regional_pool_size,]
nrow(selected_resident_only_urban_communities)
head(selected_resident_only_urban_communities)
```

And therefore
```{r}
selected_resident_columbidae_communities = all_resident_columbidae_communities[all_resident_columbidae_communities$city_id %in% selected_resident_only_urban_communities$city_id,]
head(selected_resident_only_urban_communities)
```
# Trait Data
```{yaml metadata avonet_birdlife}
models:
  - name: avonet_birdlife
    description: Functional traits taken from Avonet (Tobias et al. 2022) which includes core morphologic measurements, along with habitat preference
    columns:
      - name: species_name
        description: The birdlife species name
      - name: beak_length
        description: measured from tip to skull along the culmen
      - name: beak_width
        description: 
      - name: beak_depth
        description:
      - name: tail_length
        description:
      - name: wing_length
        description: carpal joint to wingtip measured on the unflattened wing
      - name: tarsus_length
        description:
      - name: habitat
        description: habitat preference; one of: forest, grassland, human modified, rock, shrubland, woodland, desert
      - name: habitat_density
        description: habitat density preference (1 open to 3 dense)
      - name: trophic_niche
        description: frugivore, granivore, omnivore
      - name: primary_lifestyle
        description: generalist, insessorial, terrestrial
      - name: range_size
        description: extracted range size (km2) from Birdlife
      - name: mass
        description: body mass (grams)
```

```{r read avonet_birdlife}
avonet_birdlife_input_tmp = read_csv('avonet_birdlife.csv')
avonet_birdlife = avonet_birdlife_input_tmp[,c('Species1', 'Beak.Length_Culmen', 'Beak.Width', 'Beak.Depth', 'Tail.Length', 'Wing.Length', 'Tarsus.Length', 'Habitat', 'Habitat.Density', 'Trophic.Niche', 'Primary.Lifestyle', 'Range.Size', 'Mass')]
names(avonet_birdlife) = c('species_name', 'beak_length', 'beak_width', 'beak_depth', 'tail_length', 'wing_length', 'tarsus_length', 'habitat', 'habitat_density', 'trophic_niche', 'primary_lifestyle', 'range_size', 'mass')
head(avonet_birdlife)
```

## Mapping trait data to JETZ taxonomy
```{yaml metadata birdlife_to_jetz_mapping}
models:
  - name: birdlife_to_jetz_mapping
    description: Mapping from birdlife to jetz taxonomies
    columns:
      - name: species_name
        description: The birdlife species name
      - name: jetz_scientific_name
        description: The Jetz species name
```

```{r read birdlife_to_jetz_mapping}
birdlife_to_jetz_mapping = read_csv('bigquery_export__columbidae_taxonomic_mapping.csv')
head(birdlife_to_jetz_mapping)
```

Drop species in taxonomy mapping that are not in our communities - to avoid worrying about species not in our datasets
```{r clean birdlife_to_jetz_mapping}
paste("Species not in dataset", nrow(birdlife_to_jetz_mapping[!birdlife_to_jetz_mapping$jetz_scientific_name %in% selected_columbidae_communities$jetz_scientific_name,]))
paste("Total mapped species", nrow(birdlife_to_jetz_mapping))

birdlife_to_jetz_mapping = birdlife_to_jetz_mapping[birdlife_to_jetz_mapping$jetz_scientific_name %in% selected_columbidae_communities$jetz_scientific_name,]

paste("Remaining species after removal", nrow(birdlife_to_jetz_mapping))
```

Check that we have AVONET data for all species - expect empty set
```{r}
birdlife_to_jetz_mapping[!birdlife_to_jetz_mapping$species_name %in% avonet_birdlife$species_name,]
```

Check that we have mapping entry for all community species - expect empty set
```{r}
selected_columbidae_communities[!selected_columbidae_communities$jetz_scientific_name %in% birdlife_to_jetz_mapping$jetz_scientific_name,]
```

When we map, how many duplicates do we have, and how dissimilar are they?
```{r}
avonet_birdlife_mapped_to_jetz_tmp = left_join(birdlife_to_jetz_mapping, avonet_birdlife)
duplicated_jetz_species_in_avonet = avonet_birdlife_mapped_to_jetz_tmp$jetz_scientific_name[duplicated(avonet_birdlife_mapped_to_jetz_tmp$jetz_scientific_name)]
avonet_birdlife_mapped_to_jetz_tmp[avonet_birdlife_mapped_to_jetz_tmp$jetz_scientific_name %in% duplicated_jetz_species_in_avonet,] %>% arrange(jetz_scientific_name)
```

De-duplicate avonet morphology using mean
```{r create avonet_jetz}
avonet_jetz = avonet_birdlife_mapped_to_jetz_tmp %>% group_by(jetz_scientific_name) %>% summarize(
  beak_length = mean(beak_length),
  beak_width = mean(beak_width),
  beak_depth = mean(beak_depth),
  tail_length = mean(tail_length),
  wing_length = mean(wing_length),
  tarsus_length = mean(tarsus_length),
  trophic_niche = first(trophic_niche),
  habitat = first(habitat),
  habitat_density = first(habitat_density),
  primary_lifestyle = first(primary_lifestyle),
  range_size = sum(range_size),
  mass = mean(mass)
)
head(avonet_jetz)
```

Check duplicates
```{r}
avonet_jetz[avonet_jetz$jetz_scientific_name %in% duplicated_jetz_species_in_avonet,]
```

## Creating trait values

### Trophic trait
```{r}
trophic_trait_pca = rda(avonet_jetz[,c('beak_length', 'beak_width', 'beak_depth')])
summary(trophic_trait_pca)
```
Does the new trophic trait explain trophic niche?
```{r}
summary(glm(formula = niche ~ pc1, data = data.frame(niche = as.factor(avonet_jetz$trophic_niche), pc1 = trophic_trait_pca$Ybar[,1]), family = binomial))
```
Is PC1 correlated to mass?
```{r}
cor(trophic_trait_pca$Ybar[,1], avonet_jetz$mass)
```

```{r}
avonet_jetz$trophic_trait = trophic_trait_pca$Ybar[,1]
```

### Locomotory trait
```{r}
locomotry_trait_pca = rda(avonet_jetz[,c('tarsus_length', 'wing_length', 'tail_length')])
summary(locomotry_trait_pca)
```

Is PC1 correlated to mass?
```{r}
cor(locomotry_trait_pca$Ybar[,1], avonet_jetz$mass)
```

```{r}
avonet_jetz$locomotory_trait = locomotry_trait_pca$Ybar[,1]
```

# Calculate city wide community values

## First build out matrix of all urban communities
```{r create species_in_cities}
species_in_cities = pivot_wider(selected_columbidae_communities[selected_columbidae_communities$present_in_city,c('jetz_scientific_name', 'present_in_city', 'city_id')], names_from = jetz_scientific_name, values_from = "present_in_city", values_fill = list(present_in_city = F))
species_in_cities = tibble::column_to_rownames(species_in_cities, var='city_id')
species_in_cities
```

and for resident only species
```{r create resident_species_in_cities}
resident_species_in_cities = pivot_wider(selected_resident_columbidae_communities[selected_resident_columbidae_communities$present_in_city,c('jetz_scientific_name', 'present_in_city', 'city_id')], names_from = jetz_scientific_name, values_from = "present_in_city", values_fill = list(present_in_city = F))
resident_species_in_cities = tibble::column_to_rownames(resident_species_in_cities, var='city_id')
resident_species_in_cities
```

## Read in phylogeny
Phylogenetic maximum clade tree based on a set of trees from Jetz et al. (2012) using the Hacket et al. (2008) backbone.
Trim tree to just species within our urban communities
```{r}
all_avian_species_tree <- read.tree("./phylogeny__stage2_hackett_mcc_no_neg.tre")
columbidae_tree <- ladderize(drop.tip(all_avian_species_tree, setdiff(all_avian_species_tree$tip.label, selected_columbidae_communities$jetz_scientific_name)))
```

Check that we have all species in our tree - expect empty dataset
```{r}
selected_columbidae_communities[!selected_columbidae_communities$jetz_scientific_name %in% columbidae_tree$tip.label,]
```

## MNTD
Using picante package https://cran.r-project.org/web/packages/picante/index.html
Kembel, S.W., Cowan,P.D., Helmus, M.R., Cornwell, W.K., Morlon, H., Ackerly, D.D., Blomberg, S.P., Webb, C.O. (2010) Picante: {R} tools for integrating phylogenies and ecology. Bioinformatics, 26, 1463-1464
```{r get_mntd_for_communities}
get_mntd_for_communities = function(communities, phydist_urban_columbidae = cophenetic(columbidae_tree)) {
  urban_community_mntd_result = mntd(as.matrix(communities), phydist_urban_columbidae)
  data.frame(site = rownames(communities), mntd = urban_community_mntd_result)
}

get_mntd_for_communities(species_in_cities)
```

## MTD
Using picante package https://cran.r-project.org/web/packages/picante/index.html
Citation above.
```{r get_mtd_for_communities}
get_mtd_for_communities = function(communities, phydist_urban_columbidae = cophenetic(columbidae_tree)) {
  urban_community_mtd_result = mpd(as.matrix(communities), phydist_urban_columbidae)
  data.frame(site = rownames(communities), mtd = urban_community_mtd_result)
}

get_mtd_for_communities(species_in_cities)
```

## FD - Petchey and Gaston
From
https://github.com/NGSwenson/SwensonSESYNCWorkshop2017/blob/5a966564d6896ff0f41dc4ac0a6216f97b9d18e1/day.1.pm/tree.based.alpha.R

Petchey, O.L. and Gaston, K.J. (2002), Functional diversity (FD), species richness and community composition. Ecology Letters, 5: 402-411

Create dentrogram
```{r get_dentrogram_for_traits, fig.height=4}
analysis_all_traits = c('mass', 'locomotory_trait', 'trophic_trait')

get_traits_data_frame = function(trait_names) {
  trait_names = prepend('jetz_scientific_name', trait_names)
  traits = avonet_jetz[,trait_names]
  traits = tibble::column_to_rownames(traits, var='jetz_scientific_name')
  traits
}

get_dentrogram_for_traits = function(required_traits_for_dentro) {
  traits = get_traits_data_frame(required_traits_for_dentro)
  hclust(dist(traits,method="euclidean"), method="average")
}

dentro = get_dentrogram_for_traits(analysis_all_traits)
plot(dentro)
```

Petchey and Gaston's FD
```{r get_fd_for_traits}
get_fd_for_traits = function(required_traits_for_pd, communities, dentorgram = get_dentrogram_for_traits(required_traits_for_pd)) {
  result = pd(communities, as.phylo(dentorgram))
  data.frame(site = rownames(result), fd = result$PD)
}

urban_community_fd_result = get_fd_for_traits(analysis_all_traits, species_in_cities)
head(urban_community_fd_result)
```

```{r}
urban_community_fd_mass_result = get_fd_for_traits(c('locomotory_trait'), species_in_cities)
head(urban_community_fd_mass_result)
```

## Trait Variance
### FRic - Convex Hull of all traits
Using fundiversity package https://cran.r-project.org/web/packages/fundiversity/index.html
GreniÃ© M, Gruson H (2022). fundiversity: Easy Computation of Functional Diversity Indices. doi:10.5281/zenodo.4761754, R package version 1.1.1

```{r get_convex_hull}
get_convex_hull = function(trait_names, communities) {
  analysis_trait_values = get_traits_data_frame(trait_names)
  fd_fric(analysis_trait_values, communities)
}

get_convex_hull(analysis_all_traits)
```

### Single Trait Variance
How to get names of species in urban community:
```{r}
species_in_514 = species_in_cities[c('514'),]
species_names_in_514 = names(species_in_514)[which(species_in_514 == 1, arr.ind=T)[, "col"]]
species_names_in_514
```

How to get values of traits for species in urban community, and then var of those traits:
```{r trait_values}
trait_values = function(trait, community_row) {
  species_names_in_community = names(community_row)[which(community_row == 1, arr.ind=T)[, "col"]]
  traits_for_species_in_community = avonet_jetz[avonet_jetz$jetz_scientific_name %in% species_names_in_community, ]
  traits_for_species_in_community[[c(trait)]]
}

trait_values('mass', species_in_cities[c('514'),])
var(trait_values('mass', species_in_cities[c('514'),]))
```

Turn into a function:
```{r single_trait_variance}
single_trait_variance = function(trait, communities) {
  variance_of_trait = data.frame()
  for(row in rownames(communities)) {
    community_row = communities[c(row),]
    species_names_in_community = names(community_row)[which(community_row == 1, arr.ind=T)[, "col"]]
    
    result = data.frame(site = row, variance = var(trait_values(trait, community_row)))
    variance_of_trait = rbind(variance_of_trait, result)
  }
  
  variance_of_trait
}

single_trait_variance('mass', species_in_cities)
```

## SDNDr
Standard deviation of distances between neighbouring species along a single trait axis, divided by the trait range of the community.

How to calculate SDNDr using trait values for an urban community:
```{r}
print('trait values:')
sorted_loco_traits_in_1291 = sort(trait_values('locomotory_trait', species_in_cities[c('1291'),]))
sorted_loco_traits_in_1291 

print('diff in neighbouring trait values:')
diff(sorted_loco_traits_in_1291)

print('SDNDr:')
sd(diff(sorted_loco_traits_in_1291)) / (max(sorted_loco_traits_in_1291) - min(sorted_loco_traits_in_1291))
```

Turn into a function:
```{r SDNDr}
SDNDr = function(trait, communities) {
  sdndr_of_trait = data.frame()
  for(row in rownames(communities)) {
    community_row = communities[c(row),]
    
    sorted_trait_values = sort(trait_values(trait, community_row))
    
    sdndr_value = sd(diff(sorted_trait_values)) / (max(sorted_trait_values) - min(sorted_trait_values))
    
    sdndr_of_trait = rbind(sdndr_of_trait, data.frame(site = row, sdndr = sdndr_value))
  }
  
  sdndr_of_trait
}

SDNDr('locomotory_trait', species_in_cities)
```

## Put it all together
```{r get_community_metrics}
get_community_metrics = function(communities, included_traits = analysis_all_traits) {

  mntd_result = get_mntd_for_communities(communities)
  mtd_result = get_mtd_for_communities(communities)
  fd_all_traits = get_fd_for_traits(included_traits, communities)
  convex_hull = get_convex_hull(included_traits, communities)
  
  result = right_join(right_join(mntd_result, mtd_result), right_join(fd_all_traits, convex_hull))
  
  for (trait in included_traits) {
    col_name = function(value) {
      paste(trait, value, sep = '_')
    }
  
    fd_single_trait = get_fd_for_traits(trait, communities)
    var_single_trait = single_trait_variance(trait, communities)
    sdndr_single_trait = SDNDr(trait, communities)
    
    single_trait_result = right_join(right_join(fd_single_trait, var_single_trait), sdndr_single_trait)
    names(single_trait_result) = c('site', col_name('fd'), col_name('var'), col_name('sdndr'))
    result = right_join(result, single_trait_result)
  }
  
  result
}
```

```{r create urban_community_values}
urban_community_values = get_community_metrics(species_in_cities)
urban_community_values
```

```{r create urban_resident_only_community_values}
urban_resident_only_community_values = get_community_metrics(resident_species_in_cities)
urban_resident_only_community_values
```

# Calculate the null models
Our null model is every possible community of species from the regional pool with the same richness as the urban pool

Find all species in regional pool:
```{r}
test_city_id = 1786 # Manchester

all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == test_city_id]
```

```{r}
all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == test_city_id]
```

Find urban richness
```{r}
selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == test_city_id]
```

Function to build every possible community
```{r create_null_model_communities}
create_null_model_communities = function(city_id, urban_richness, regional_species) {
  regional_richness = length(regional_species)
  
  null_model_sites = expand.grid(rep(list(TRUE:FALSE), regional_richness))
  null_model_sites_species_richness =  data.frame(species_richness = pmap_dbl(null_model_sites, sum))
  null_model_sites = cbind(null_model_sites, null_model_sites_species_richness)
  
  null_model_sites = null_model_sites[null_model_sites$species_richness == urban_richness,1:regional_richness]
  colnames(null_model_sites) = regional_species
  null_model_sites
}

create_null_model_communities(
  test_city_id, 
  selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == test_city_id], 
  all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == test_city_id]
)
```

What were the results for the actual urban community in Manchester?
```{r}
urban_community_values[urban_community_values$site == test_city_id,]
```

Test creating community metrics for our null model
```{r}
test_null_models = create_null_model_communities(
  test_city_id, 
  selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == test_city_id],
  all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == test_city_id]
)

test_null_model_community_values = get_community_metrics(test_null_models)
test_null_model_community_values
```

```{r}
test_city_id2 = 8
get_community_metrics(
  create_null_model_communities(
    test_city_id2, 
    selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == test_city_id2],
    all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == test_city_id2]
  )
)
```

# Compare Urban Communities to regional null models
```{r normalise}
normalise = function(actual_value, min_value, max_value) {
  (actual_value - min_value) / (max_value - min_value)
}

normalise(1.5, 1, 2)
```

```{r standardise}
standardise = function(actual_value, mean_value, sd) {
  (actual_value - mean_value) / sd
}

standardise(1.5, 1, 0.25)
```

Test creating normalised and standardised FRic
```{r}
property = 'FRic'
actual_value = urban_community_values[urban_community_values$site == test_city_id,c(property)]
null_model_values = test_null_model_community_values[,c(property)]

print(paste('Normalised', property, 'at site', test_city_id))
normalise(actual_value, min(null_model_values), max(null_model_values))
print(paste('Standardised', property, 'at site', test_city_id))
standardise(actual_value, mean(null_model_values), sd(null_model_values))
```

Create function to test actual value against all possible null model values
```{r compare_community_to_null_model}
compare_community_to_null_model = function(metric_name, actual_metric_value, null_model_metric_values) {
  min_value = min(null_model_metric_values)
  max_value = max(null_model_metric_values)
  mean_value = mean(null_model_metric_values)
  sd_value = sd(null_model_metric_values)
  
  result = data.frame(
    normalised = normalise(actual_metric_value, min_value, max_value),
    stanardised = standardise(actual_metric_value, mean_value, sd_value),
    actual = actual_metric_value,
    min = min_value,
    max = max_value,
    mean = mean_value,
    sd = sd_value
  )
  
  col_name = function(value) {
      paste(metric_name, value, sep = '_')
  }
  
  colnames(result) = c(col_name('normalised'), col_name('standardised'), col_name('actual'), col_name('min'), col_name('max'), col_name('mean'), col_name('sd'))
  result
}

compare_community_to_null_model(property, actual_value, null_model_values)
```

The metrics we want to test:
```{r create all_metrics_to_test}
all_metrics_to_test = colnames(urban_community_values)[-1]
all_metrics_to_test
```

Compare the actual values to the null model values:
```{r create_null_model_test_values}
create_null_model_test_values = function(city_id, urban_richness, regional_species, actual_values) {
  null_models = create_null_model_communities(city_id, urban_richness, regional_species)
  null_model_community_values = get_community_metrics(null_models)
  
  result = data.frame(city_id = city_id)
  
  for (metric in all_metrics_to_test) {
    result = cbind(result, 
                   compare_community_to_null_model(metric, actual_values[,c(metric)], null_model_community_values[,c(metric)]))
  }
  result
}

create_null_model_test_values(
  test_city_id, 
  selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == test_city_id],
  all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == test_city_id], 
  urban_community_values[urban_community_values$site == test_city_id,]
)
```


```{r}
create_null_model_test_values(
  test_city_id2, 
  selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == test_city_id2],
  all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == test_city_id2],
  urban_community_values[urban_community_values$site == test_city_id2,]
)
```

And for resident only species
```{r}
create_null_model_test_values(
  test_city_id2, 
  selected_resident_only_urban_communities$urban_pool_size[selected_resident_only_urban_communities$city_id == test_city_id2],
  all_resident_columbidae_communities$jetz_scientific_name[all_resident_columbidae_communities$city_id == test_city_id2],
  urban_resident_only_community_values[urban_resident_only_community_values$site == test_city_id2,]
)
```


```{r create urban_all_species_community_result}
urban_all_species_community_result = data.frame()

for (loop_all_city_id in selected_urban_communities$city_id) {
  city_null_models_all_species = create_null_model_test_values(
    loop_all_city_id, 
    selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == loop_all_city_id],
    all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == loop_all_city_id],
    urban_community_values[urban_community_values$site == loop_all_city_id,]
  )
  
  urban_all_species_community_result = rbind(urban_all_species_community_result, city_null_models_all_species)
}

urban_all_species_community_result = right_join(urban_all_species_community_result, selected_urban_communities)

write_csv(urban_all_species_community_result, './community_assembly_all_species_result.csv')
head(urban_all_species_community_result)
```

```{r create urban_resident_only_species_community_result, eval = FALSE}
urban_resident_only_species_community_result = data.frame()

for (loop_resident_city_id in selected_resident_only_urban_communities$city_id) {
  city_null_models_resident_species = create_null_model_test_values(
    loop_resident_city_id, 
    selected_resident_only_urban_communities$urban_pool_size[selected_resident_only_urban_communities$city_id == loop_resident_city_id],
    all_resident_columbidae_communities$jetz_scientific_name[all_resident_columbidae_communities$city_id == loop_resident_city_id],
    urban_resident_only_community_values[urban_resident_only_community_values$site == loop_resident_city_id,]
  )
  
  urban_resident_only_species_community_result = rbind(urban_resident_only_species_community_result, city_null_models_resident_species)
}

urban_resident_only_species_community_result = right_join(urban_resident_only_species_community_result, selected_urban_communities)

write_csv(urban_resident_only_species_community_result, './community_assembly_resident_species_result.csv')
head(urban_resident_only_species_community_result)
```

```{r}
urban_all_species_community_result = read_csv('./community_assembly_all_species_result.csv')
urban_all_species_community_result
```

```{r}
urban_resident_only_species_community_result = read_csv('./community_assembly_resident_species_result.csv')
urban_resident_only_species_community_result
```

# Analysis
Total number of cities in analysis
```{r}
nrow(urban_all_species_community_result)
```

Total number of cities in resident only species analysis
```{r}
nrow(urban_resident_only_species_community_result)
```

## Analysis of all traits across entire community

### MNTD
Pairwise phylogenetic distances separating each species from its closest co-occurring relative and is most sensitive to phylogenetic clustering or evenness at the tips of phylogeny.

```{r}
fmt_p_value = function(test_result) {
  ifelse(test_result$p.value > 0.001, paste('=', round(test_result$p.value, 3)), '< 0.001')
}

geom_standardised_histogram = function(name, gg, test_result, mean) {
    gg + geom_histogram(color = "#000000", fill = "#0099F8", binwidth = 0.25) +
    geom_vline(aes(xintercept = 0), color = "#000000", size = 1.25) +
    geom_vline(aes(xintercept = -1), color = "#000000", size = 1, linetype = "dashed") +
    geom_vline(aes(xintercept = 1), color = "#000000", size = 1, linetype = "dashed") + 
    ylab("Number of cities") + xlab("Standardised Response") + ylim(c(0, 150)) + xlim(c(-3, 3)) +
    labs(title = name, subtitle=paste('(V=', test_result$statistic, ', p-value ', fmt_p_value(test_result), ', mean = ', round(mean, 2), ')', sep=''))
}

geom_normalised_histogram = function(name, gg, test_result, mean) {
  gg + geom_histogram(color = "#000000", fill = "#0099F8", binwidth = 0.1) +
  geom_vline(aes(xintercept = 0.5), color = "#000000", size = 1.25) +
  geom_vline(aes(xintercept = 0), color = "#000000", size = 1, linetype = "dashed") +
  geom_vline(aes(xintercept = 1), color = "#000000", size = 1, linetype = "dashed") + 
  ylab("Number of cities") + xlab("Normalised Response") + ylim(c(0, 200)) +
  labs(title = name, subtitle = paste('(V=', test_result$statistic, ', p-value ', fmt_p_value(test_result), ', mean = ', round(mean, 2), ')', sep=''))
}
```

#### All species
Standardised 
```{r}
std_mntd_analysis_plot = geom_standardised_histogram(
  'MNTD', 
  ggplot(urban_all_species_community_result, aes(mntd_standardised)), 
  wilcox.test(urban_all_species_community_result$mntd_standardised, mu = 0), 
  mean(urban_all_species_community_result$mntd_standardised)
)
std_mntd_analysis_plot
```

Normalised
```{r}
norm_mntd_analysis_plot = geom_normalised_histogram(
  'MNTD', 
  ggplot(urban_all_species_community_result, aes(mntd_normalised)), 
  wilcox.test(urban_all_species_community_result$mntd_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$mntd_normalised)
)
norm_mntd_analysis_plot
```

#### Resident only species
Normalised
```{r}
norm_mntd_analysis_plot_ro = geom_normalised_histogram(
  'MNTD', 
  ggplot(urban_resident_only_species_community_result, aes(mntd_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$mntd_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$mntd_normalised)
)
norm_mntd_analysis_plot_ro
```

### MTD
Mean pairwise phylogenetic distances between co-occurring species and is most sensitive to tree-wide patterns of phylogenetic clustering and evenness.

#### All species
Standardised 
```{r}
std_mtd_analysis_plot = geom_standardised_histogram(
  'MTD', 
  ggplot(urban_all_species_community_result, aes(mtd_standardised)), 
  wilcox.test(urban_all_species_community_result$mtd_standardised, mu = 0), 
  mean(urban_all_species_community_result$mtd_standardised)
)
std_mtd_analysis_plot
```

Normalised
```{r}
norm_mtd_analysis_plot = geom_normalised_histogram(
  'MTD', 
  ggplot(urban_all_species_community_result, aes(mtd_normalised)), 
  wilcox.test(urban_all_species_community_result$mtd_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$mtd_normalised)
)
norm_mtd_analysis_plot
```


#### Resident only species
Normalised
```{r}
norm_mtd_analysis_plot_ro = geom_normalised_histogram(
  'MTD', 
  ggplot(urban_resident_only_species_community_result, aes(mtd_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$mtd_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$mtd_normalised)
)
norm_mtd_analysis_plot_ro
```

### All Traits FD

#### All species
Standardised 
```{r}
std_fd_analysis_plot = geom_standardised_histogram(
  'FD', 
  ggplot(urban_all_species_community_result, aes(fd_standardised)), 
  wilcox.test(urban_all_species_community_result$fd_standardised, mu = 0), 
  mean(urban_all_species_community_result$fd_standardised)
)
std_fd_analysis_plot
```

Normalised:
```{r}
norm_fd_analysis_plot = geom_normalised_histogram(
  'FD', 
  ggplot(urban_all_species_community_result, aes(fd_normalised)), 
  wilcox.test(urban_all_species_community_result$fd_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$fd_normalised)
)
norm_fd_analysis_plot
```

#### Resident only species
Normalised
```{r}
norm_fd_analysis_plot_ro = geom_normalised_histogram(
  'FD', 
  ggplot(urban_resident_only_species_community_result, aes(fd_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$fd_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$fd_normalised)
)
norm_fd_analysis_plot_ro
```


### FRic
Number of cities that we could calculate FRic for, need 4 or more species (as require more species than traits)

#### All species
Standardised 
```{r}
std_fric_analysis_plot = geom_standardised_histogram(
  'FRic', 
  ggplot(urban_all_species_community_result, aes(FRic_standardised)), 
  wilcox.test(urban_all_species_community_result$FRic_standardised, mu = 0), 
  mean(urban_all_species_community_result$FRic_standardised, na.rm = T)
)
std_fric_analysis_plot
```

Normalised
```{r}
norm_fric_analysis_plot = geom_normalised_histogram(
  'FRic', 
  ggplot(urban_all_species_community_result, aes(FRic_normalised)), 
  wilcox.test(urban_all_species_community_result$FRic_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$FRic_normalised, na.rm = T)
)
norm_fric_analysis_plot
```

#### Resident only species
Normalised
```{r}
norm_fric_analysis_plot_ro = geom_normalised_histogram(
  'FRic', 
  ggplot(urban_resident_only_species_community_result, aes(FRic_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$FRic_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$FRic_normalised, na.rm = T)
)
norm_fric_analysis_plot_ro
```

## Single Trait Metrics

Number of cities we can calculate SDNDr for - require at least 3 species
```{r}
nrow(urban_all_species_community_result[!is.na(urban_all_species_community_result$mass_sdndr_actual),])
```

### Locomotory Trait

#### FD

##### All species
Standardised 
```{r}
std_loco_trait_fd_analysis_plot = geom_standardised_histogram(
  'Locomotory Trait - FD', 
  ggplot(urban_all_species_community_result, aes(locomotory_trait_fd_standardised)), 
  wilcox.test(urban_all_species_community_result$locomotory_trait_fd_standardised, mu = 0), 
  mean(urban_all_species_community_result$locomotory_trait_fd_standardised, na.rm = T)
)
std_loco_trait_fd_analysis_plot
```

Normalised
```{r}
norm_loco_trait_fd_analysis_plot = geom_normalised_histogram(
  'Locomotory Trait - FD', 
  ggplot(urban_all_species_community_result, aes(locomotory_trait_fd_normalised)), 
  wilcox.test(urban_all_species_community_result$locomotory_trait_fd_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$locomotory_trait_fd_normalised, na.rm = T)
)
norm_loco_trait_fd_analysis_plot
```

##### Resident only species
Normalised
```{r}
norm_loco_trait_fd_analysis_plot_ro = geom_normalised_histogram(
  'Locomotory Trait - FD', 
  ggplot(urban_resident_only_species_community_result, aes(locomotory_trait_fd_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$locomotory_trait_fd_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$locomotory_trait_fd_normalised, na.rm = T)
)
norm_loco_trait_fd_analysis_plot_ro
```

#### VAR

##### All species
Standardised 
```{r}
std_loco_trait_var_analysis_plot = geom_standardised_histogram(
  'Locomotory Trait - VAR', 
  ggplot(urban_all_species_community_result, aes(locomotory_trait_var_standardised)), 
  wilcox.test(urban_all_species_community_result$locomotory_trait_var_standardised, mu = 0), 
  mean(urban_all_species_community_result$locomotory_trait_var_standardised, na.rm = T)
)
std_loco_trait_var_analysis_plot
```

Normalised
```{r}
norm_loco_trait_var_analysis_plot = geom_normalised_histogram(
  'Locomotory Trait - VAR', 
  ggplot(urban_all_species_community_result, aes(locomotory_trait_var_normalised)), 
  wilcox.test(urban_all_species_community_result$locomotory_trait_var_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$locomotory_trait_var_normalised, na.rm = T)
)
norm_loco_trait_var_analysis_plot
```

##### Resident only species
Normalised
```{r}
norm_loco_trait_var_analysis_plot_ro = geom_normalised_histogram(
  'Locomotory Trait - VAR', 
  ggplot(urban_resident_only_species_community_result, aes(locomotory_trait_var_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$locomotory_trait_var_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$locomotory_trait_var_normalised, na.rm = T)
)
norm_loco_trait_var_analysis_plot_ro
```

#### SDNDr

##### All species
Standardised 
```{r}
std_loco_trait_sdndr_analysis_plot = geom_standardised_histogram(
  'Locomotory Trait - SDNDr', 
  ggplot(urban_all_species_community_result, aes(locomotory_trait_sdndr_standardised)), 
  wilcox.test(urban_all_species_community_result$locomotory_trait_sdndr_standardised, mu = 0), 
  mean(urban_all_species_community_result$locomotory_trait_sdndr_standardised, na.rm = T)
)
std_loco_trait_sdndr_analysis_plot
```

Normalised
```{r}
norm_loco_trait_sdndr_analysis_plot = geom_normalised_histogram(
  'Locomotory Trait - SDNDr', 
  ggplot(urban_all_species_community_result, aes(locomotory_trait_sdndr_normalised)), 
  wilcox.test(urban_all_species_community_result$locomotory_trait_sdndr_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$locomotory_trait_sdndr_normalised, na.rm = T)
)
norm_loco_trait_sdndr_analysis_plot
```

##### Resident only species
Normalised
```{r}
norm_loco_trait_sdndr_analysis_plot_ro = geom_normalised_histogram(
  'Locomotory Trait - SDNDr', 
  ggplot(urban_resident_only_species_community_result, aes(locomotory_trait_sdndr_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$locomotory_trait_sdndr_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$locomotory_trait_sdndr_normalised, na.rm = T)
)
norm_loco_trait_sdndr_analysis_plot_ro
```

### Trophic Trait

#### FD

##### All species
Standardised 
```{r}
std_trophic_trait_fd_analysis_plot = geom_standardised_histogram(
  'Trophic Trait - FD', 
  ggplot(urban_all_species_community_result, aes(trophic_trait_fd_standardised)), 
  wilcox.test(urban_all_species_community_result$trophic_trait_fd_standardised, mu = 0), 
  mean(urban_all_species_community_result$trophic_trait_fd_standardised, na.rm = T)
)
std_trophic_trait_fd_analysis_plot
```

Normalised
```{r}
norm_trophic_trait_fd_analysis_plot = geom_normalised_histogram(
  'Trophic Trait - FD', 
  ggplot(urban_all_species_community_result, aes(trophic_trait_fd_normalised)), 
  wilcox.test(urban_all_species_community_result$trophic_trait_fd_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$trophic_trait_fd_normalised, na.rm = T)
)
norm_trophic_trait_fd_analysis_plot
```

##### Resident only species
Normalised
```{r}
norm_trophic_trait_fd_analysis_plot_ro = geom_normalised_histogram(
  'Trophic Trait - FD', 
  ggplot(urban_resident_only_species_community_result, aes(trophic_trait_fd_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$trophic_trait_fd_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$trophic_trait_fd_normalised, na.rm = T)
)
norm_trophic_trait_fd_analysis_plot_ro
```

#### VAR

##### All species
Standardised 
```{r}
std_trophic_trait_var_analysis_plot = geom_standardised_histogram(
  'Trophic Trait - VAR', 
  ggplot(urban_all_species_community_result, aes(trophic_trait_var_standardised)), 
  wilcox.test(urban_all_species_community_result$trophic_trait_var_standardised, mu = 0), 
  mean(urban_all_species_community_result$trophic_trait_var_standardised, na.rm = T)
)
std_trophic_trait_var_analysis_plot
```

Normalised
```{r}
norm_trophic_trait_var_analysis_plot = geom_normalised_histogram(
  'Trophic Trait - VAR', 
  ggplot(urban_all_species_community_result, aes(trophic_trait_var_normalised)), 
  wilcox.test(urban_all_species_community_result$trophic_trait_var_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$trophic_trait_var_normalised, na.rm = T)
)
norm_trophic_trait_var_analysis_plot
```

##### Resident only species
Normalised
```{r}
norm_trophic_trait_var_analysis_plot_ro = geom_normalised_histogram(
  'Trophic Trait - VAR', 
  ggplot(urban_resident_only_species_community_result, aes(trophic_trait_var_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$trophic_trait_var_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$trophic_trait_var_normalised, na.rm = T)
)
norm_trophic_trait_var_analysis_plot_ro
```

#### SDNDr

##### All species
Standardised 
```{r}
std_trophic_trait_sdndr_analysis_plot = geom_standardised_histogram(
  'Trophic Trait - SDNDr', 
  ggplot(urban_all_species_community_result, aes(trophic_trait_sdndr_standardised)), 
  wilcox.test(urban_all_species_community_result$trophic_trait_sdndr_standardised, mu = 0), 
  mean(urban_all_species_community_result$trophic_trait_sdndr_standardised, na.rm = T)
)
std_trophic_trait_sdndr_analysis_plot
```

Normalised
```{r}
norm_trophic_trait_sdndr_analysis_plot = geom_normalised_histogram(
  'Trophic Trait - SDNDr', 
  ggplot(urban_all_species_community_result, aes(trophic_trait_sdndr_normalised)), 
  wilcox.test(urban_all_species_community_result$trophic_trait_sdndr_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$trophic_trait_sdndr_normalised, na.rm = T)
)
norm_trophic_trait_sdndr_analysis_plot
```

##### Resident only species
Normalised
```{r}
norm_trophic_trait_sdndr_analysis_plot_ro = geom_normalised_histogram(
  'Trophic Trait - SDNDr', 
  ggplot(urban_resident_only_species_community_result, aes(trophic_trait_sdndr_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$trophic_trait_sdndr_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$trophic_trait_sdndr_normalised, na.rm = T)
)
norm_trophic_trait_sdndr_analysis_plot_ro
```

### Mass

#### FD

##### All species
Standardised 
```{r}
std_mass_fd_analysis_plot = geom_standardised_histogram(
  'Mass - FD', 
  ggplot(urban_all_species_community_result, aes(mass_fd_standardised)), 
  wilcox.test(urban_all_species_community_result$mass_fd_standardised, mu = 0), 
  mean(urban_all_species_community_result$mass_fd_standardised, na.rm = T)
)
std_mass_fd_analysis_plot
```

Normalised
```{r}
norm_mass_fd_analysis_plot = geom_normalised_histogram(
  'Mass - FD', 
  ggplot(urban_all_species_community_result, aes(mass_fd_normalised)), 
  wilcox.test(urban_all_species_community_result$mass_fd_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$mass_fd_normalised, na.rm = T)
)
norm_mass_fd_analysis_plot
```

##### Resident only species
Normalised
```{r}
norm_mass_fd_analysis_plot_ro = geom_normalised_histogram(
  'Mass - FD', 
  ggplot(urban_resident_only_species_community_result, aes(mass_fd_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$mass_fd_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$mass_fd_normalised, na.rm = T)
)
norm_mass_fd_analysis_plot_ro
```

#### VAR

##### All species
Standardised 
```{r}
std_mass_var_analysis_plot = geom_standardised_histogram(
  'Mass - VAR', 
  ggplot(urban_all_species_community_result, aes(mass_var_standardised)), 
  wilcox.test(urban_all_species_community_result$mass_var_standardised, mu = 0), 
  mean(urban_all_species_community_result$mass_var_standardised, na.rm = T)
)
std_mass_var_analysis_plot
```

Normalised
```{r}
norm_mass_var_analysis_plot = geom_normalised_histogram(
  'Mass - VAR', 
  ggplot(urban_all_species_community_result, aes(mass_var_normalised)), 
  wilcox.test(urban_all_species_community_result$mass_var_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$mass_var_normalised, na.rm = T)
)
norm_mass_var_analysis_plot
```

##### Resident only species
Normalised
```{r}
norm_mass_var_analysis_plot_ro = geom_normalised_histogram(
  'Mass - VAR', 
  ggplot(urban_resident_only_species_community_result, aes(mass_var_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$mass_var_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$mass_var_normalised, na.rm = T)
)
norm_mass_var_analysis_plot_ro
```

#### SDNDr

##### All species
Standardised 
```{r}
std_mass_sdndr_analysis_plot = geom_standardised_histogram(
  'Mass - SDNDr', 
  ggplot(urban_all_species_community_result, aes(mass_sdndr_standardised)), 
  wilcox.test(urban_all_species_community_result$mass_sdndr_standardised, mu = 0), 
  mean(urban_all_species_community_result$mass_sdndr_standardised, na.rm = T)
)
std_mass_sdndr_analysis_plot
```

Normalised
```{r}
norm_mass_sdndr_analysis_plot = geom_normalised_histogram(
  'Mass - SDNDr', 
  ggplot(urban_all_species_community_result, aes(mass_sdndr_normalised)), 
  wilcox.test(urban_all_species_community_result$mass_sdndr_normalised, mu = 0.5), 
  mean(urban_all_species_community_result$mass_sdndr_normalised, na.rm = T)
)
norm_mass_sdndr_analysis_plot
```

##### Resident only species
Normalised
```{r}
norm_mass_sdndr_analysis_plot_ro = geom_normalised_histogram(
  'Mass - SDNDr', 
  ggplot(urban_resident_only_species_community_result, aes(mass_sdndr_normalised)), 
  wilcox.test(urban_resident_only_species_community_result$mass_sdndr_normalised, mu = 0.5), 
  mean(urban_resident_only_species_community_result$mass_sdndr_normalised, na.rm = T)
)
norm_mass_sdndr_analysis_plot_ro
```

## Create Figures

### All Traits

Standardised
```{r, fig.height=3, fig.width=3}
ggarrange(std_mntd_analysis_plot, std_mtd_analysis_plot, std_fric_analysis_plot, std_fd_analysis_plot, ncol = 2, nrow = 2)
```

Normalised
```{r, fig.height=3, fig.width=3}
ggarrange(norm_mntd_analysis_plot, norm_mtd_analysis_plot, norm_fric_analysis_plot, norm_fd_analysis_plot, ncol = 2, nrow = 2)
```

Strong evidence for competitive exclusion shaping urban communities, three of the four metrics are significantly higher than would be expected by random.  The only metric that is not higher than expected nor significant is FRic. Could this be because FRic only includes urban communities with 3 or more species?

We can check the normalised response for FD against urban community size to see if there is any evidence of larger communities being less likely to be shaped by competitive exclusion. This shows that larger pools do have a much lower mean for normalised FD response and therefore the FRic result could be down to only larger pools being included.  More species could well be present when more habitat is available in the city, and thus there is sufficient habitat to help species avoid getting involved in competitive interactions.

```{r}
ggplot(urban_all_species_community_result, aes(y = fd_normalised, x = as.factor(urban_pool_size))) + geom_boxplot()
```
```{r, fig.height=3, fig.width=3}
blank <- grid.rect(gp=gpar(col="white"))

point_plot = function(points_aes) {
  ggplot(urban_all_species_community_result, points_aes) + 
    geom_point(size = 0.5, aes(color = as.factor(urban_pool_size))) + 
    scale_x_continuous(position = 'top') +
    guides(color=guide_legend(title="Urban richness", nrow=1)) +
    theme_bw()
}

ggarrange(
  point_plot(aes(x = fd_normalised, y = mntd_normalised)) + ylab("MNTD") + xlab("FD"),
  point_plot(aes(x = FRic_normalised, y = mntd_normalised)) + rremove("ylab") + xlab("FRic"),
  point_plot(aes(x = mtd_normalised, y = mntd_normalised)) + rremove("ylab") + xlab("MTD"),
  point_plot(aes(x = fd_normalised, y = mtd_normalised)) + ylab("MTD") + rremove("xlab"),
  point_plot(aes(x = FRic_normalised, y = mtd_normalised)) + rremove("ylab") + rremove("xlab"),
  blank,
  point_plot(aes(x = fd_normalised, y = FRic_normalised)) + ylab("FRic") + rremove("xlab"),
  blank,
  blank
  , ncol = 3, nrow = 3, common.legend = T, legend = "bottom")
```

```{r}
jpeg('./figures/community_assembly_community.jpg', width = 1200, height = 800)
ggarrange(norm_mntd_analysis_plot + theme_bw(), norm_mtd_analysis_plot + theme_bw(), norm_fric_analysis_plot + theme_bw(), norm_fd_analysis_plot + theme_bw(), ncol = 2, nrow = 2)
dev.off()
```

```{r}
jpeg('./figures/community_assembly_community_compared.jpg', width = 1200, height = 800)
ggarrange(
  point_plot(aes(x = fd_normalised, y = mntd_normalised)) + ylab("MNTD") + xlab("FD"),
  point_plot(aes(x = FRic_normalised, y = mntd_normalised)) + rremove("ylab") + xlab("FRic"),
  point_plot(aes(x = mtd_normalised, y = mntd_normalised)) + rremove("ylab") + xlab("MTD"),
  point_plot(aes(x = fd_normalised, y = mtd_normalised)) + ylab("MTD") + rremove("xlab"),
  point_plot(aes(x = FRic_normalised, y = mtd_normalised)) + rremove("ylab") + rremove("xlab"),
  blank,
  point_plot(aes(x = fd_normalised, y = FRic_normalised)) + ylab("FRic") + rremove("xlab"),
  blank,
  blank
  , ncol = 3, nrow = 3, common.legend = T, legend = "bottom")
dev.off()
```

Normalised - resident only species
```{r, fig.height=3, fig.width=3}
ggarrange(norm_mntd_analysis_plot_ro, norm_mtd_analysis_plot_ro, norm_fric_analysis_plot_ro, norm_fd_analysis_plot_ro, ncol = 2, nrow = 2)
```

### Single Traits
Standardised
```{r, fig.height=6, fig.width=6}
ggarrange(
  std_loco_trait_fd_analysis_plot, std_loco_trait_var_analysis_plot, std_loco_trait_sdndr_analysis_plot,
  std_trophic_trait_fd_analysis_plot, std_trophic_trait_var_analysis_plot, std_trophic_trait_sdndr_analysis_plot,
  std_mass_fd_analysis_plot, std_mass_var_analysis_plot, std_mass_sdndr_analysis_plot,
  ncol = 3, nrow = 3)
```

Normalised
```{r, fig.height=6, fig.width=6}
ggarrange(
  norm_loco_trait_fd_analysis_plot, norm_loco_trait_var_analysis_plot, norm_loco_trait_sdndr_analysis_plot,
  norm_trophic_trait_fd_analysis_plot, norm_trophic_trait_var_analysis_plot, norm_trophic_trait_sdndr_analysis_plot,
  norm_mass_fd_analysis_plot, norm_mass_var_analysis_plot, norm_mass_sdndr_analysis_plot,
  ncol = 3, nrow = 3)
```

Higher than expected values for the locomotory trait FD and mass FD, along with lower than expected values for the locomotory trait SDNDr and mass SDNDr give some evidence that both these traits are selected under competitive exclusion.  VAR in both cases gives the opposite view, this is the single trait version of FRic.
While the trophic trait has a higher than expected FD, its SDNDr value is fairly close to the mean and therefore this trait may not be selected under competitive exclusion.
Also, Trisos et al. (2014) discourage the use of multi-pattern metrics such as variance and range, which are sensitive to both clustering and over-dispersion, in single-pattern, one-tailed hypothesis tests.

```{r}
jpeg('./figures/community_assembly_single_traits.jpg', width = 1200, height = 800)
ggarrange(
  norm_loco_trait_fd_analysis_plot + theme_bw(), norm_loco_trait_var_analysis_plot + theme_bw(), norm_loco_trait_sdndr_analysis_plot + theme_bw(),
  norm_trophic_trait_fd_analysis_plot + theme_bw(), norm_trophic_trait_var_analysis_plot + theme_bw(), norm_trophic_trait_sdndr_analysis_plot + theme_bw(),
  norm_mass_fd_analysis_plot + theme_bw(), norm_mass_var_analysis_plot + theme_bw(), norm_mass_sdndr_analysis_plot + theme_bw(),
  ncol = 3, nrow = 3)
dev.off()
```

Locomotory metrics compared
```{r}
ggarrange(
  point_plot(aes(x = locomotory_trait_var_normalised, y = locomotory_trait_fd_normalised)) + ylab("FD") + xlab("VAR"),
  point_plot(aes(x = locomotory_trait_sdndr_normalised, y = locomotory_trait_fd_normalised)) + rremove("ylab") + xlab("SDNDr"),
  ncol = 2, nrow = 1, common.legend = T, legend = "bottom")
```
Trophic metrics compared
```{r}
ggarrange(
  point_plot(aes(x = trophic_trait_var_normalised, y = trophic_trait_fd_normalised)) + ylab("FD") + xlab("VAR"),
  point_plot(aes(x = trophic_trait_sdndr_normalised, y = trophic_trait_fd_normalised)) + rremove("ylab") + xlab("SDNDr"),
  ncol = 2, nrow = 1, common.legend = T, legend = "bottom")
```

Mass metrics compared
```{r}
ggarrange(
  point_plot(aes(x = mass_var_normalised, y = mass_fd_normalised)) + ylab("FD") + xlab("VAR"),
  point_plot(aes(x = mass_sdndr_normalised, y = mass_fd_normalised)) + rremove("ylab") + xlab("SDNDr"),
  ncol = 2, nrow = 1, common.legend = T, legend = "bottom")
```

Normalised - resident only species
```{r, fig.height=6, fig.width=6}
ggarrange(
  norm_loco_trait_fd_analysis_plot_ro, norm_loco_trait_var_analysis_plot_ro, norm_loco_trait_sdndr_analysis_plot_ro,
  norm_trophic_trait_fd_analysis_plot_ro, norm_trophic_trait_var_analysis_plot_ro, norm_trophic_trait_sdndr_analysis_plot_ro,
  norm_mass_fd_analysis_plot_ro, norm_mass_var_analysis_plot_ro, norm_mass_sdndr_analysis_plot_ro,
  ncol = 3, nrow = 3)
```

# Impact of Introduced species

## Is there any difference in MNTD or FD of cities with introduced species?
```{r}
wilcox.test(urban_all_species_community_result$fd_normalised ~ as.factor(urban_all_species_community_result$number_of_urban_introduced_species))
```

```{r}
ggplot(urban_all_species_community_result, aes(y = fd_normalised, x = as.factor(number_of_urban_introduced_species))) + geom_boxplot()
```
```{r}
wilcox.test(urban_all_species_community_result$mntd_normalised ~ as.factor(urban_all_species_community_result$number_of_urban_introduced_species))
```

```{r}
ggplot(urban_all_species_community_result, aes(y = mntd_normalised, x = as.factor(number_of_urban_introduced_species))) + geom_boxplot()
```

## Calculate maximum possible diversity held by urban community if no Feral Pigeon

All communities without Feral Pigeon
```{r}
all_columbidae_communities_no_feral_pig = all_columbidae_communities[all_columbidae_communities$jetz_scientific_name != 'Columba_livia',]
head(all_columbidae_communities_no_feral_pig)
```

Cities with Columba Livia as an introduced species
```{r}
city_ids_with_introduced_species = unique(all_columbidae_communities$city_id[all_columbidae_communities$jetz_scientific_name == 'Columba_livia' & all_columbidae_communities$origin == 'Introduced' & all_columbidae_communities$present_in_city])
length(city_ids_with_introduced_species)
```

Cities for analysis
```{r}
selected_urban_communties_with_introduced_species = selected_urban_communities[selected_urban_communities$city_id %in% city_ids_with_introduced_species,]
head(selected_urban_communties_with_introduced_species)
```

Create all possible communities for city with same richness but no introduced species, and fetch community assembly metrics for these communities
```{r}
create_null_model_communities(
  test_city_id, 
  selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == test_city_id],
  all_columbidae_communities_no_feral_pig$jetz_scientific_name[all_columbidae_communities_no_feral_pig$city_id == test_city_id]
)

get_community_metrics(
  create_null_model_communities(
    test_city_id, 
    selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == test_city_id],
    all_columbidae_communities_no_feral_pig$jetz_scientific_name[all_columbidae_communities_no_feral_pig$city_id == test_city_id]
  )
)
```

Create a function to build a comparison result for comparing min/max possible values with no introduced species to actual community value
```{r}
compare_actual_result_to_no_introduced = function(metric, possible_community_metrics_with_no_introduced, actual_community_metrics_result) {
  max_no_introduced_value = max(possible_community_metrics_with_no_introduced[,c(metric)])
  min_no_introduced_value = min(possible_community_metrics_with_no_introduced[,c(metric)])
  
  col_name = function(postscript) {
    paste(metric, postscript, sep = '_')
  }
  
  actual_value_normalised = actual_community_metrics_result[,c(col_name('normalised'))]
  actual_value = actual_community_metrics_result[,c(col_name('actual'))]
  actual_value_min = actual_community_metrics_result[,c(col_name('min'))]
  actual_value_max = actual_community_metrics_result[,c(col_name('max'))]
  
  result = data.frame(
    max_possible_value_with_no_introduced_normalised = normalise(max_no_introduced_value, actual_value_min, actual_value_max),
    min_possible_value_with_no_introduced_normalised = normalise(min_no_introduced_value, actual_value_min, actual_value_max),
    actual_value_normalised = actual_value_normalised,
    max_possible_value_with_no_introduced = max_no_introduced_value,
    min_possible_value_with_no_introduced = min_no_introduced_value,
    actual_value = actual_value
  )
  
  colnames(result) = c(col_name('max_possible_value_with_no_introduced_normalised'), 
                       col_name('min_possible_value_with_no_introduced_normalised'),
                       col_name('actual_value_normalised'), 
                       col_name('max_possible_value_with_no_introduced'), 
                       col_name('min_possible_value_with_no_introduced'), 
                       col_name('actual_value'))
  result
}

test_possible_community_values_with_no_introduced = get_community_metrics(
  create_null_model_communities(
    test_city_id, 
    selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == test_city_id],
    all_columbidae_communities$jetz_scientific_name[all_columbidae_communities$city_id == test_city_id & all_columbidae_communities$origin != 'Introduced']
  )
)
  
compare_actual_result_to_no_introduced(
  'fd', 
  test_possible_community_values_with_no_introduced, 
  urban_all_species_community_result[urban_all_species_community_result$city_id == test_city_id,]
)
```

Build a function to create values for all possible urban communities with no introduced species, and then compare to actual community values.
```{r}
compare_all_metrics_actual_result_to_no_introduced = function(city_id, urban_richness, regional_species, actual_urban_species_community_result) {
  possible_community_values_with_no_introduced_species = get_community_metrics(
    create_null_model_communities(
      city_id, 
      selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == city_id],
      all_columbidae_communities_no_feral_pig$jetz_scientific_name[all_columbidae_communities_no_feral_pig$city_id == city_id]
    )
  )
  
  result = data.frame(city_id = city_id)
  
  for(metric in all_metrics_to_test) {
    result = cbind(result,
                   compare_actual_result_to_no_introduced(metric, possible_community_values_with_no_introduced_species, actual_urban_species_community_result))
  }
  
  result
}

compare_all_metrics_actual_result_to_no_introduced(
  test_city_id, 
  selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == test_city_id],
  all_columbidae_communities_no_feral_pig$jetz_scientific_name[all_columbidae_communities_no_feral_pig$city_id == test_city_id],
  urban_all_species_community_result[urban_all_species_community_result$city_id == test_city_id,]
)
```

Create result for each city in this analysis
```{r, eval = FALSE}
urban_no_introduced_species_community_result = data.frame()

for(no_introduced_loop_city_id in selected_urban_communties_with_introduced_species$city_id) {
  print(no_introduced_loop_city_id)
  regional_species = all_columbidae_communities_no_feral_pig$jetz_scientific_name[all_columbidae_communities_no_feral_pig$city_id == no_introduced_loop_city_id ]
  
  # We need at least 2 regional species (once introduced removed) to complete analysis
  if (length(regional_species) > 1) {
    urban_no_introduced_species_community_result = rbind(urban_no_introduced_species_community_result,
      compare_all_metrics_actual_result_to_no_introduced(
        no_introduced_loop_city_id, 
        selected_urban_communities$urban_pool_size[selected_urban_communities$city_id == no_introduced_loop_city_id],
        regional_species,
        urban_all_species_community_result[urban_all_species_community_result$city_id == no_introduced_loop_city_id,]
      )
    )
  }
}

write_csv(urban_no_introduced_species_community_result, './community_assembly_no_introduced_species_result.csv')
head(urban_no_introduced_species_community_result)
```

```{r}
urban_no_introduced_species_community_result = read_csv('./community_assembly_no_introduced_species_result.csv')
urban_no_introduced_species_community_result
```

```{r}
urban_no_introduced_species_community_result[urban_no_introduced_species_community_result$mntd_max_possible_value_with_no_introduced_normalised < 0,]
```

## Compare the possible values with no introduced species to the actual value

### MNTD
```{r}
compare_actual_to_no_introduced = function(metric, no_introduced_values, actual_values, city_ids) {
  comparison_df = rbind(
    data.frame(value = no_introduced_values, type = 'No introduced species', id = city_ids),
    data.frame(value = actual_values, type = 'Actual', id = city_ids)
  )
  
  wilcox_test_mntd = wilcox.test(no_introduced_values, actual_values, paired = T)
  
  ggplot(comparison_df, aes(x = type, y = value)) + 
    geom_boxplot() + 
    geom_line(aes(group = id), size = 0.1) +  
    xlab('Urban Community') + 
    ylab(paste('Normalised', metric)) + 
    labs(subtitle = paste("(V = ", wilcox_test_mntd$statistic, ", p-value", fmt_p_value(wilcox_test_mntd), ")"))
}

compare_actual_to_no_introduced('MNTD', 
  urban_no_introduced_species_community_result$mntd_max_possible_value_with_no_introduced_normalised,
  urban_no_introduced_species_community_result$mntd_actual_value_normalised,
  urban_no_introduced_species_community_result$city_id
)
```

### MTD
```{r}
compare_actual_to_no_introduced('MTD', 
  urban_no_introduced_species_community_result$mtd_max_possible_value_with_no_introduced_normalised,
  urban_no_introduced_species_community_result$mtd_actual_value_normalised,
  urban_no_introduced_species_community_result$city_id
)
```
### FD
```{r}
compare_actual_to_no_introduced('FD', 
  urban_no_introduced_species_community_result$fd_max_possible_value_with_no_introduced_normalised,
  urban_no_introduced_species_community_result$fd_actual_value_normalised,
  urban_no_introduced_species_community_result$city_id
)
```

### FRic
```{r}
compare_actual_to_no_introduced('FRic', 
  urban_no_introduced_species_community_result$FRic_max_possible_value_with_no_introduced_normalised,
  urban_no_introduced_species_community_result$FRic_actual_value_normalised,
  urban_no_introduced_species_community_result$city_id
)
```
